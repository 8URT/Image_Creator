<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Social Media Image Creator</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Fira+Sans:wght@400;500;600;700;800;900&display=swap" rel="stylesheet" />
  <link href="https://fonts.googleapis.com/css2?family=Parkinsans:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Hanken+Grotesk:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">

  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    // Template configuration from server
    const templateConfig = {{ template_config | tojson }};
  </script>

  <style>
    /* Dark Mode Colors */
    body {
      background-color: #1a202c; /* Dark background for the body */
      color: #f7fafc; /* Light text color for the body */
    }
    .gradient-bg {
      background: #1a202c; /* Consistent dark background for the main wrapper */
    }
    .bg-white { /* This class is now used for control panel, renamed for clarity */
      background-color: #2d3748; /* Darker background for panels */
      color: #f7fafc; /* Light text for panels */
    }
    /* Updated title color */
    .text-gray-800 {
      color: #3F51B5; /* Social Media Image Creator title color */
    }
    .border-gray-200 { /* Used for control panel border */
      border-color: #4a5568; /* Darker borders */
    }
    .border-gray-300 { /* Used for input borders */
      border-color: #718096; /* Slightly lighter dark borders for inputs */
    }
    /* Adjusted text colors for better visibility in dark mode */
    .text-gray-600 {
      color: #cbd5e0; /* Lighter gray for labels and tips */
    }
    .text-gray-500 {
        color: #a0aec0; /* Slightly darker gray for range slider values */
    }
    .bg-gray-100 { /* Used for pro tip box */
      background-color: #4a5568; /* Darker background for info boxes */
      color: #f7fafc; /* Light text for info boxes */
    }
    .text-blue-600 {
      color: #66aaff; /* Brighter blue for accents */
    }
    .focus\:border-blue-500 {
      border-color: #66aaff; /* Blue border on focus */
    }
    .focus\:ring-blue-100 {
      box-shadow: 0 0 0 0.2rem rgba(102, 170, 255, 0.25); /* Blue ring on focus */
    }
    .hover\:border-blue-500 {
      border-color: #66aaff; /* Blue border on hover */
    }
    .hover\:bg-blue-50 {
      background-color: rgba(102, 170, 255, 0.05); /* Very light blue background on hover */
    }
    /* Gradient buttons for dark mode */
    .import-button, .generate-button, .download-button {
      background: linear-gradient(135deg, #66aaff 0%, #4299e1 100%);
      color: #f7fafc; /* Light text for buttons */
    }
    .import-button:hover, .generate-button:hover, .download-button:hover {
      box-shadow: 0 5px 15px rgba(102, 170, 255, 0.4); /* Blue shadow on hover */
      -webkit-transform: translateY(-1px);
      transform: translateY(-1px);
    }
    .ring-blue-500 {
      box-shadow: 0 0 0 3px rgba(102, 170, 255, 0.5);
    }

    /* New style for the Image Size Mode button */
    #imageSizeMode {
        background: linear-gradient(135deg, #9C27B0 0%, #2196F3 100%); /* Purple to Blue gradient */
        color: #f7fafc; /* Light text color */
        border: none; /* Remove border */
        outline: none; /* Remove default outline */
        box-shadow: 0 0 0 0.1rem rgba(156, 39, 176, 0.5); /* Subtle focus ring */
        transition: all 0.3s ease; /* Ensure smooth transitions for focus */
    }

    #imageSizeMode:hover {
        box-shadow: 0 5px 15px rgba(156, 39, 176, 0.4); /* Matching shadow on hover */
        transform: translateY(-1px);
    }

    /* Canvas specific styles */
    #canvas {
      max-width: 100%;
      height: auto;
      background-color: #4a5568; /* Darker canvas background for contrast */
      border: 1px solid #718096; /* Subtle border for the canvas */
    }

    /* Style for the drag-over state */
    .drag-over {
        border-color: #66aaff !important; /* Blue border for drag over */
        background-color: #2c5282 !important; /* Darker blue background for drag over */
        color: #f7fafc !important; /* Ensure text is visible */
    }

    /* Range slider dark mode styles */
    input[type="range"] {
        background-color: #4a5568; /* Darker track for range slider */
    }
    input[type="range"]::-webkit-slider-thumb {
      background: #66aaff;
      border: 1px solid #4299e1;
    }
    input[type="range"]::-moz-range-thumb {
      background: #66aaff;
      border: 1px solid #4299e1;
    }
    input[type="range"]::-ms-thumb {
      background: #66aaff;
      border: 1px solid #4299e1;
    }
    /* Input field background and text */
    input[type="text"], input[type="number"], textarea, select {
      background-color: #2d3748;
      color: #f7fafc;
      border-color: #4a5568;
    }
    input[type="text"]::placeholder, textarea::placeholder {
      color: #a0aec0; /* Muted placeholder text */
    }
    /* Updated drop zone background */
    #imageDropZone {
        background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%); /* Darker gradient */
    }
    #imageDropZone:hover {
        border-color: #718096; /* Darker hover border */
        box-shadow: 0 5px 15px rgba(0,0,0,0.3); /* Darker shadow */
    }
    /* Format button styles */
    .format-button {
      background: #4a5568;
      color: #f7fafc;
      border: 2px solid #4a5568;
    }
    /* Subtitle background swatch styles */
    .subtitle-bg-swatch.active {
      border-color: #66aaff !important;
      border-width: 3px !important;
      box-shadow: 0 0 0 2px rgba(102, 170, 255, 0.3);
    }
    /* Gradient background swatch styles */
    .gradient-bg-swatch.active {
      border-color: #66aaff !important;
      border-width: 3px !important;
      box-shadow: 0 0 0 2px rgba(102, 170, 255, 0.3);
    }
    .format-button:hover {
      background: #2d3748;
      border-color: #718096;
    }
    /* Social button - Facebook blue when active */
    #formatSocial.active {
      background: #1877F2; /* Facebook blue */
      border-color: #1877F2;
      color: white;
    }
    /* Website button - Default red when active */
    #formatWebsite.active {
      background: #d41c1c; /* Default red */
      border-color: #d41c1c;
      color: white;
    }
  </style>
</head>
<body class="min-h-screen gradient-bg p-4 font-['Fira_Sans']">
  <div class="max-w-5xl mx-auto">
    <div class="text-gray-800 text-center py-2 mb-3">
      <h1 class="text-4xl font-extrabold">Social Media Image Creator</h1>
    </div>

    <div class="rounded-3xl overflow-hidden">
      <div class="grid lg:grid-cols-[1fr_320px] gap-4 p-4">
        <div class="flex justify-center items-start">
          <canvas id="canvas" width="1000" height="1250" class="rounded-xl shadow-xl bg-white"></canvas>
        </div>

        <div class="bg-white p-5 rounded-2xl shadow-lg border border-gray-200">
          <div class="mb-4">
            <div class="flex gap-2">
              <button type="button" id="formatSocial" class="flex-1 px-4 py-2 rounded-xl font-bold transition-all duration-300 text-sm format-button active" data-format="social">
                Social Image
              </button>
              <button type="button" id="formatWebsite" class="flex-1 px-4 py-2 rounded-xl font-bold transition-all duration-300 text-sm format-button" data-format="website">
                Website Image
              </button>
            </div>
          </div>

          <div id="imageDropZone" class="border-4 border-dotted border-gray-400 rounded-2xl p-5 text-center mb-4 transition-all duration-300 cursor-pointer hover:border-gray-500 hover:shadow-lg hover:-translate-y-1">
              <input type="file" id="imageUpload" accept="image/*" class="hidden" />
              <button type="button" onclick="document.getElementById('imageUpload').click()" class="import-button text-white px-4 py-2 rounded-full font-bold transition-all duration-300 hover:-translate-y-1 text-sm">Select Image</button>
          </div>

          <button type="button" id="imageSizeMode" class="w-full px-4 py-2 mb-4 rounded-xl font-bold transition-all duration-300 hover:-translate-y-1 text-sm">
            Fill Frame (Cover)
          </button>

          <div id="imagePositionControls" class="mb-4">
            <div class="grid grid-cols-4 gap-3 mb-4">
              <div>
                <label for="imageOffsetX" class="block font-bold text-gray-600 mb-1 text-xs text-center">
                  ‚Üê ‚Üí
                </label>
                <input type="range" id="imageOffsetX" min="-500" max="500" value="0" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
              </div>
              <div>
                <label for="imageOffsetY" class="block font-bold text-gray-600 mb-1 text-xs text-center">
                  ‚Üë ‚Üì
                </label>
                <input type="range" id="imageOffsetY" min="-500" max="500" value="0" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
              </div>
              <div>
                <label for="imageZoom" class="block font-bold text-gray-600 mb-1 text-xs text-center">
                  - üîç +
                </label>
                <input type="range" id="imageZoom" min="1" max="300" value="100" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
              </div>
              <div class="flex items-end">
                <button type="button" id="resetImageControls" class="w-full h-8 flex items-center justify-center bg-gray-200 hover:bg-gray-300 rounded-lg transition-all duration-300 cursor-pointer" title="Reset to defaults">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-gray-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                  </svg>
                </button>
              </div>
            </div>
          </div>

          <div class="space-y-4 mb-4">
            <div>
              <input type="text" id="subtitle" placeholder="Subtitle in caps" maxlength="60" class="w-full px-3 py-2 border-2 border-gray-300 rounded-xl focus:border-blue-500 focus:ring-4 focus:ring-blue-100 transition-all duration-300 text-sm" />
            </div>

            <div>
              <textarea id="title" rows="3" placeholder="Main title here..." maxlength="400" class="w-full px-3 py-2 border-2 border-gray-300 rounded-xl focus:border-blue-500 focus:ring-4 focus:ring-blue-100 transition-all duration-300 resize-y min-h-[60px] text-sm"></textarea>
            </div>

            <div>
              <label class="block font-bold text-gray-600 mb-1 text-xs">
                Text Block Vertical Position: <span id="verticalPositionValue">100</span>px
              </label>
              <input type="range" id="verticalPositionSlider" min="0" max="100" value="100" step="1" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer slider" />
            </div>
          </div>

          <div class="space-y-4">
            <div>
                <select id="fontStyleSelect" class="w-full px-3 py-2 border-2 border-gray-300 rounded-xl focus:border-blue-500 focus:ring-4 focus:ring-blue-100 transition-all duration-300 text-sm">
                    <option value="Fira Sans">Font: Fira Sans (Default)</option>
                    <option value="Parkinsans">Font: Parkinsans (Magazine)</option>
                    <option value="Hanken Grotesk">Font: Hanken Grotesk</option>
                    <option value="Inter" selected>Font: Inter</option>
                    <option value="IBM Plex Sans">Font: IBM Plex Sans</option>
                </select>
            </div>

            <div class="grid grid-cols-2 gap-2">
              <div>
                <label class="block font-bold text-gray-600 mb-1 text-xs">Title Size (px):</label>
                <input type="number" id="titleSize" value="70" min="36" max="140" placeholder="Title size" class="w-full px-3 py-2 border-2 border-gray-300 rounded-xl focus:border-blue-500 focus:ring-4 focus:ring-blue-100 transition-all duration-300 text-sm" />
              </div>
              <div>
                <label class="block font-bold text-gray-600 mb-1 text-xs">Subtitle Size (px):</label>
                <input type="number" id="subtitleSize" value="40" min="20" max="80" placeholder="Subtitle size" class="w-full px-3 py-2 border-2 border-gray-300 rounded-xl focus:border-blue-500 focus:ring-4 focus:ring-blue-100 transition-all duration-300 text-sm" />
              </div>
            </div>

            <div>
              <select id="placement" class="w-full px-3 py-2 border-2 border-gray-300 rounded-xl focus:border-blue-500 focus:ring-4 focus:ring-blue-100 transition-all duration-300 text-sm">
                <option value="1">Alignment: Top Left</option>
                <option value="3" selected>Alignment: Bottom Left</option>
                <option value="5">Alignment: Top Center</option>
                <option value="6">Alignment: Bottom Center</option>
              </select>
            </div>

            <div class="mt-2 mb-2">
              <label class="block font-bold text-gray-600 mb-1 text-xs">Subtitle Background:</label>
              <div class="flex gap-1 items-center">
                <button type="button" id="subtitleBgTransparent" class="subtitle-bg-swatch w-5 h-5 border-2 border-gray-400 rounded cursor-pointer hover:border-blue-500 transition-all" style="background: repeating-conic-gradient(#808080 0% 25%, #c0c0c0 0% 50%) 50% / 8px 8px;" title="Transparent" data-color="transparent"></button>
                <button type="button" id="subtitleBgRed" class="subtitle-bg-swatch w-5 h-5 border-2 border-gray-400 rounded cursor-pointer hover:border-blue-500 transition-all bg-[#d41c1c]" title="Red" data-color="#d41c1c"></button>
                <button type="button" id="subtitleBgBlack" class="subtitle-bg-swatch w-5 h-5 border-2 border-gray-400 rounded cursor-pointer hover:border-blue-500 transition-all bg-black" title="Black" data-color="#000000"></button>
                <button type="button" id="subtitleBgWhite" class="subtitle-bg-swatch w-5 h-5 border-2 border-gray-400 rounded cursor-pointer hover:border-blue-500 transition-all bg-white" title="White" data-color="#FFFFFF"></button>
                <button type="button" id="subtitleBgDarkGrey" class="subtitle-bg-swatch w-5 h-5 border-2 border-gray-400 rounded cursor-pointer hover:border-blue-500 transition-all" style="background: rgba(0, 0, 0, 0.5);" title="Black 50% Opacity" data-color="rgba(0, 0, 0, 0.5)"></button>
              </div>
            </div>

            <div class="mt-2 mb-2">
              <label class="block font-bold text-gray-600 mb-1 text-xs">Gradient Shadow:</label>
              <div class="flex gap-1 items-center">
                <button type="button" id="gradientBgTransparent" class="gradient-bg-swatch w-5 h-5 border-2 border-gray-400 rounded cursor-pointer hover:border-blue-500 transition-all" style="background: repeating-conic-gradient(#808080 0% 25%, #c0c0c0 0% 50%) 50% / 8px 8px;" title="Transparent" data-color="transparent"></button>
                <button type="button" id="gradientBgRed" class="gradient-bg-swatch w-5 h-5 border-2 border-gray-400 rounded cursor-pointer hover:border-blue-500 transition-all bg-[#d41c1c]" title="Red" data-color="#d41c1c"></button>
                <button type="button" id="gradientBgBlack" class="gradient-bg-swatch w-5 h-5 border-2 border-gray-400 rounded cursor-pointer hover:border-blue-500 transition-all bg-black" title="Black" data-color="#000000"></button>
                <button type="button" id="gradientBgBlue" class="gradient-bg-swatch w-5 h-5 border-2 border-gray-400 rounded cursor-pointer hover:border-blue-500 transition-all" style="background: #0773D8;" title="Blue" data-color="#0773D8"></button>
                <button type="button" id="gradientBgPink" class="gradient-bg-swatch w-5 h-5 border-2 border-gray-400 rounded cursor-pointer hover:border-blue-500 transition-all" style="background: #FF009D;" title="Pink" data-color="#FF009D"></button>
              </div>
            </div>

            <div class="mt-4 mb-2">
              <button type="button" id="advancedOptionsToggle" class="w-full px-3 py-2 bg-gray-100 hover:bg-gray-200 border-2 border-gray-300 rounded-xl font-bold text-gray-700 transition-all duration-300 text-sm flex items-center justify-center">
                <span>Advanced Options</span>
                <svg id="advancedOptionsIcon" xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 ml-2 transition-transform duration-300" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                </svg>
              </button>
            </div>

            <div id="advancedOptions" class="space-y-4 hidden">
            <div>
              <label class="block font-bold text-gray-600 mb-1 text-xs">Title Font Weight:</label>
              <select id="titleWeightSelect" class="w-full px-3 py-2 border-2 border-gray-300 rounded-xl focus:border-blue-500 focus:ring-4 focus:ring-blue-100 transition-all duration-300 text-sm">
                <option value="400">400 (Regular)</option>
                <option value="500">500 (Medium)</option>
                <option value="600" selected>600 (Semi Bold)</option>
                <option value="700">700 (Bold)</option>
                <option value="800">800 (Extra Bold)</option>
                <option value="900">900 (Black)</option>
              </select>
            </div>

            <div>
              <label class="block font-bold text-gray-600 mb-1 text-xs">
                Title Kerning: <span id="kerningValue">-2</span>px
              </label>
              <input type="range" id="kerningSlider" min="-2" max="0" value="-2" step="0.5" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer slider" />
            </div>

            <div class="grid grid-cols-2 gap-2">
                <div>
                    <label class="block font-bold text-gray-600 mb-1 text-xs">Subtitle Color:</label>
                    <div class="flex gap-2">
                        <input type="color" id="subtitleColorPicker" value="#FFFFFF" class="w-1/2 h-8 border-2 border-gray-300 rounded-md cursor-pointer" />
                        <select id="subtitleColorPresets" class="w-1/2 px-2 py-1 border-2 border-gray-300 rounded-xl focus:border-blue-500 focus:ring-4 focus:ring-blue-100 transition-all duration-300 text-sm">
                            <option value="#FFFFFF" selected>White</option>
                            <option value="#000000">Black</option>
                            <option value="#FFF200">Cool Yellow</option>
                            <option value="#00BFFF">Deep Sky Blue</option>
                        </select>
                    </div>
                </div>
            </div>

            <div class="grid grid-cols-2 gap-2">
                <div class="col-span-2">
                    <label class="block font-bold text-gray-600 mb-1 text-xs">Subtitle Background Color:</label>
                    <div class="flex gap-2">
                        <input type="color" id="subtitleBackgroundColorPicker" value="#d41c1c" class="w-1/2 h-8 border-2 border-gray-300 rounded-md cursor-pointer" />
                        <select id="subtitleBackgroundColorPresets" class="w-1/2 px-2 py-1 border-2 border-gray-300 rounded-xl focus:border-blue-500 focus:ring-4 focus:ring-blue-100 transition-all duration-300 text-sm">
                            <option value="#d41c1c" selected>Default Red</option>
                            <option value="#000000">Black</option>
                            <option value="#FFFFFF">White</option>
                        </select>
                    </div>
                </div>
            </div>

            <div>
                <label class="block font-bold text-gray-600 mb-1 text-xs">Background Blend Mode:</label>
                <select id="backgroundBlendMode" class="w-full px-3 py-2 border-2 border-gray-300 rounded-xl focus:border-blue-500 focus:ring-4 focus:ring-100 transition-all duration-300 text-sm">
                    <option value="source-over" selected>Normal</option>
                    <option value="multiply">Multiply</option>
                    <option value="screen">Screen</option>
                    <option value="overlay">Overlay</option>
                    <option value="darken">Darken</option>
                    <option value="lighten">Lighten</option>
                </select>
            </div>

            <div class="flex items-center">
              <input type="checkbox" id="turfLogoToggle" class="mr-2 h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded" />
              <label for="turfLogoToggle" class="block font-bold text-gray-600 text-xs">Show Turf Logo</label>
            </div>
            </div>

            <div class="flex gap-3 pt-4">
              <button onclick="drawCanvas()" class="generate-button flex-1 text-white px-4 py-3 rounded-xl font-bold transition-all duration-300 hover:-translate-y-1 hover:shadow-lg text-sm">Generate Image</button>
              <button onclick="downloadImage()" class="download-button flex-1 text-white px-4 py-3 rounded-xl font-bold transition-all duration-300 hover:-translate-y-1 hover:shadow-lg text-sm">Download Image</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const imageInput = document.getElementById('imageUpload');
    const titleInput = document.getElementById('title');
    const subtitleInput = document.getElementById('subtitle');
    const placementInput = document.getElementById('placement');
    const titleSizeInput = document.getElementById('titleSize');
    const subtitleSizeInput = document.getElementById('subtitleSize');
    const titleWeightSelect = document.getElementById('titleWeightSelect');
    const kerningSlider = document.getElementById('kerningSlider');
    const kerningValue = document.getElementById('kerningValue');
    const verticalPositionSlider = document.getElementById('verticalPositionSlider');
    const verticalPositionValue = document.getElementById('verticalPositionValue');
    const subtitleColorPicker = document.getElementById('subtitleColorPicker');
    const subtitleColorPresets = document.getElementById('subtitleColorPresets');

    const subtitleBackgroundColorPicker = document.getElementById('subtitleBackgroundColorPicker');
    const subtitleBackgroundColorPresets = document.getElementById('subtitleBackgroundColorPresets');
    
    // Subtitle background swatch elements
    const subtitleBgSwatches = {
      transparent: document.getElementById('subtitleBgTransparent'),
      red: document.getElementById('subtitleBgRed'),
      black: document.getElementById('subtitleBgBlack'),
      white: document.getElementById('subtitleBgWhite'),
      darkGrey: document.getElementById('subtitleBgDarkGrey')
    };
    
    // Track subtitle background state
    let subtitleBgEnabled = false;
    let subtitleBgColor = '#d41c1c'; // Default red (but transparent is default)

    const backgroundBlendMode = document.getElementById('backgroundBlendMode');
    
    // Gradient background swatch elements
    const gradientBgSwatches = {
      transparent: document.getElementById('gradientBgTransparent'),
      red: document.getElementById('gradientBgRed'),
      black: document.getElementById('gradientBgBlack'),
      blue: document.getElementById('gradientBgBlue'),
      pink: document.getElementById('gradientBgPink')
    };
    
    // Track gradient background color state
    let gradientBgColor = '#000000'; // Default black
    let gradientBgEnabled = true; // Gradient is always enabled (transparent just means no gradient)

    const imageSizeModeButton = document.getElementById('imageSizeMode');
    let imageCoverMode = true; // Changed default to Cover, as per button text

    const imageOffsetXInput = document.getElementById('imageOffsetX');
    const imageOffsetYInput = document.getElementById('imageOffsetY');
    const imageZoomInput = document.getElementById('imageZoom');
    const resetImageControls = document.getElementById('resetImageControls');

    let currentImageOffsetX = 0;
    let currentImageOffsetY = 0;
    let currentImageZoom = 100;

    const fontStyleSelect = document.getElementById('fontStyleSelect');
    const turfLogoToggle = document.getElementById('turfLogoToggle');
    const formatSocial = document.getElementById('formatSocial');
    const formatWebsite = document.getElementById('formatWebsite');

    // Format state: 'social' or 'website'
    let currentFormat = 'social';
    const SOCIAL_FORMAT = { width: 1000, height: 1250 };
    const WEBSITE_FORMAT = { width: 1000, height: 500 };

    let uploadedImage = null;

    const turfLogo = new Image();
    turfLogo.src = '{{ url_for("static", filename="assets/turf_logo.png") }}';
    let turfLogoLoaded = false;
    turfLogo.onload = () => {
      turfLogoLoaded = true;
      drawCanvas();
    };
    turfLogo.onerror = () => {
      console.warn("Turf logo (turf_logo.png) failed to load.");
      turfLogoLoaded = false;
      drawCanvas();
    };

    const mlinfoLogo = new Image();
    mlinfoLogo.src = '{{ url_for("static", filename="assets/mlinfo_lm.png") }}';
    let mlinfoLogoLoaded = false;
    mlinfoLogo.onload = () => {
      mlinfoLogoLoaded = true;
      drawCanvas();
    };
    mlinfoLogo.onerror = () => {
      console.warn("ML Info logo (mlinfo_lm.png) failed to load.");
      mlinfoLogoLoaded = false;
      drawCanvas();
    };

    function handlePaste(e) {
      const items = e.clipboardData?.items;
      if (!items) return;

      for (let item of items) {
        if (item.type.startsWith('image/')) {
          e.preventDefault();
          const file = item.getAsFile();
          if (file) {
            loadImageFromFile(file);
          }
          break;
        }
      }
    }

    function loadImageFromFile(file) {
      if (!file.type.startsWith('image/')) {
        alert("Please upload an image file (e.g., JPEG, PNG, GIF).");
        return;
      }

      const reader = new FileReader();
      reader.onload = () => {
        const img = new Image();
        img.onload = () => {
          uploadedImage = img;
          resetImageTransforms();
          drawCanvas();
        };
        img.onerror = () => {
          alert("Could not load image. Please try another file.");
          uploadedImage = null;
          drawCanvas();
        };
        img.src = reader.result;
      };
      reader.readAsDataURL(file);
    }

    document.addEventListener('paste', handlePaste);
    document.getElementById('imageDropZone').addEventListener('paste', handlePaste);
    document.getElementById('imageDropZone').setAttribute('tabindex', '0');

    const imageDropZone = document.getElementById('imageDropZone');
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
      imageDropZone.addEventListener(eventName, preventDefaults, false);
      document.body.addEventListener(eventName, preventDefaults, false);
    });

    function preventDefaults (e) {
      e.preventDefault();
      e.stopPropagation();
    }

    ['dragenter', 'dragover'].forEach(eventName => {
      imageDropZone.addEventListener(eventName, highlight, false);
    });

    ['dragleave', 'drop'].forEach(eventName => {
      imageDropZone.addEventListener(eventName, unhighlight, false);
    });

    function highlight() {
      imageDropZone.classList.add('drag-over');
    }

    function unhighlight() {
      imageDropZone.classList.remove('drag-over');
    }

    imageDropZone.addEventListener('drop', handleDrop, false);

    function handleDrop(e) {
      const dt = e.dataTransfer;
      const files = dt.files;

      if (files.length > 0) {
        loadImageFromFile(files?.[0]);
      }
    }

    imageInput.addEventListener('change', (e) => {
      const file = e.target.files?.[0];
      if (!file) {
        uploadedImage = null;
        drawCanvas();
        return;
      }
      loadImageFromFile(file);
    });

    ([
      titleInput, subtitleInput, placementInput,
      titleSizeInput, subtitleSizeInput, titleWeightSelect, kerningSlider, verticalPositionSlider,
      turfLogoToggle,
      subtitleBackgroundColorPicker, subtitleBackgroundColorPresets,
      backgroundBlendMode,
      imageOffsetXInput, imageOffsetYInput, imageZoomInput
    ]).forEach(el => {
      el.addEventListener('input', drawCanvas);
    });
    
    turfLogoToggle.addEventListener('change', drawCanvas);
    
    // Advanced Options toggle
    const advancedOptionsToggle = document.getElementById('advancedOptionsToggle');
    const advancedOptions = document.getElementById('advancedOptions');
    const advancedOptionsIcon = document.getElementById('advancedOptionsIcon');
    
    advancedOptionsToggle.addEventListener('click', () => {
      const isHidden = advancedOptions.classList.contains('hidden');
      if (isHidden) {
        advancedOptions.classList.remove('hidden');
        advancedOptionsIcon.style.transform = 'rotate(180deg)';
      } else {
        advancedOptions.classList.add('hidden');
        advancedOptionsIcon.style.transform = 'rotate(0deg)';
      }
    });
    
    // Format toggle handlers
    formatSocial.addEventListener('click', () => {
      currentFormat = 'social';
      formatSocial.classList.add('active');
      formatWebsite.classList.remove('active');
      updateCanvasSize();
      // Reset transforms to maintain image proportions when switching formats
      resetImageTransforms();
      // Force redraw to recalculate image dimensions for new canvas size
      drawCanvas();
    });

    formatWebsite.addEventListener('click', () => {
      currentFormat = 'website';
      formatWebsite.classList.add('active');
      formatSocial.classList.remove('active');
      updateCanvasSize();
      // Reset transforms to maintain image proportions when switching formats
      resetImageTransforms();
      // Force redraw to recalculate image dimensions for new canvas size
      drawCanvas();
    });

    function updateCanvasSize() {
      const format = currentFormat === 'social' ? SOCIAL_FORMAT : WEBSITE_FORMAT;
      
      // Update canvas internal dimensions (resolution)
      canvas.width = format.width;
      canvas.height = format.height;
      
      // The CSS already has max-width: 100% and height: auto which maintains aspect ratio
      // We just need to ensure the canvas element respects its natural aspect ratio
      // by not setting explicit width/height that would override the CSS
      
      // If there was an image, it will be redrawn with correct proportions in drawCanvas()
      // The image calculation in drawCanvas() uses uploadedImage.width/height which are
      // the natural dimensions, so it will maintain aspect ratio correctly
    }
    
    titleWeightSelect.addEventListener('change', drawCanvas);
    
    kerningSlider.addEventListener('input', (e) => {
      kerningValue.textContent = parseFloat(e.target.value).toFixed(1);
      drawCanvas();
    });
    
    verticalPositionSlider.addEventListener('input', (e) => {
      // The actual pixel value will be calculated in drawCanvas
      drawCanvas();
    });

    subtitleColorPicker.addEventListener('input', () => {
        const selectedValue = subtitleColorPicker.value.toUpperCase();
        let found = false;
        for (let i = 0; i < subtitleColorPresets.options.length; i++) {
            if (subtitleColorPresets.options?.[i]?.value?.toUpperCase() === selectedValue) {
                subtitleColorPresets.selectedIndex = i;
                found = true;
                break;
            }
        }
        if (!found) {
            subtitleColorPresets.selectedIndex = -1;
        }
        drawCanvas();
    });

    subtitleColorPresets.addEventListener('change', () => {
        subtitleColorPicker.value = subtitleColorPresets.value;
        drawCanvas();
    });

    imageSizeModeButton.addEventListener('click', () => {
      imageCoverMode = !imageCoverMode;
      imageSizeModeButton.textContent = imageCoverMode ? 'Fit to Frame' : 'Fill Frame (Cover)';
      resetImageTransforms();
      drawCanvas();
    });

    function resetImageTransforms() {
        currentImageOffsetX = 0;
        currentImageOffsetY = 0;
        currentImageZoom = 100;

        imageOffsetXInput.value = 0;
        imageOffsetYInput.value = 0;
        imageZoomInput.value = 100;
    }

    imageOffsetXInput.addEventListener('input', (e) => {
        currentImageOffsetX = parseInt(e.target.value);
        drawCanvas();
    });

    imageOffsetYInput.addEventListener('input', (e) => {
        currentImageOffsetY = parseInt(e.target.value);
        drawCanvas();
    });

    imageZoomInput.addEventListener('input', (e) => {
        currentImageZoom = parseInt(e.target.value);
        drawCanvas();
    });

    // Reset button functionality
    resetImageControls.addEventListener('click', () => {
        currentImageOffsetX = 0;
        currentImageOffsetY = 0;
        currentImageZoom = 100;
        
        imageOffsetXInput.value = 0;
        imageOffsetYInput.value = 0;
        imageZoomInput.value = 100;
        
        drawCanvas();
    });

    // Subtitle background swatch click handlers
    function setSubtitleBackground(color) {
        // Remove active class from all swatches
        Object.values(subtitleBgSwatches).forEach(swatch => {
            if (swatch) swatch.classList.remove('active');
        });
        
        if (color === 'transparent') {
            subtitleBgEnabled = false;
            subtitleBgSwatches.transparent?.classList.add('active');
            // Set subtitle text color to white for transparent background
            subtitleColorPicker.value = '#FFFFFF';
            subtitleColorPresets.value = '#FFFFFF';
        } else {
            subtitleBgEnabled = true;
            subtitleBgColor = color;
            subtitleBackgroundColorPicker.value = color;
            
            // Set subtitle text color based on background
            if (color === '#FFFFFF') {
                // White background -> black text
                subtitleColorPicker.value = '#000000';
                subtitleColorPresets.value = '#000000';
            } else {
                // All other colors -> white text
                subtitleColorPicker.value = '#FFFFFF';
                subtitleColorPresets.value = '#FFFFFF';
            }
            
            // Set active swatch based on color
            if (color === '#d41c1c') {
                subtitleBgSwatches.red?.classList.add('active');
            } else if (color === '#000000') {
                subtitleBgSwatches.black?.classList.add('active');
            } else if (color === '#FFFFFF') {
                subtitleBgSwatches.white?.classList.add('active');
            } else if (color === 'rgba(0, 0, 0, 0.5)' || color === 'rgba(0,0,0,0.5)') {
                subtitleBgSwatches.darkGrey?.classList.add('active');
            }
        }
        drawCanvas();
    }
    
    // Add click handlers to swatches
    subtitleBgSwatches.transparent?.addEventListener('click', () => setSubtitleBackground('transparent'));
    subtitleBgSwatches.red?.addEventListener('click', () => setSubtitleBackground('#d41c1c'));
    subtitleBgSwatches.black?.addEventListener('click', () => setSubtitleBackground('#000000'));
    subtitleBgSwatches.white?.addEventListener('click', () => setSubtitleBackground('#FFFFFF'));
    subtitleBgSwatches.darkGrey?.addEventListener('click', () => setSubtitleBackground('rgba(0, 0, 0, 0.5)'));
    
    // Initialize with transparent selected (default)
    setSubtitleBackground('transparent');

    subtitleBackgroundColorPicker.addEventListener('input', () => {
        const selectedValue = subtitleBackgroundColorPicker.value.toUpperCase();
        let found = false;
        for (let i = 0; i < subtitleBackgroundColorPresets.options.length; i++) {
            if (subtitleBackgroundColorPresets.options?.[i]?.value?.toUpperCase() === selectedValue) {
                subtitleBackgroundColorPresets.selectedIndex = i;
                found = true;
                break;
            }
        }
        if (!found) {
            subtitleBackgroundColorPresets.selectedIndex = -1;
        }
        // Update swatch if color matches
        if (selectedValue === '#D41C1C') {
            setSubtitleBackground('#d41c1c');
        } else if (selectedValue === '#000000') {
            setSubtitleBackground('#000000');
        } else if (selectedValue === '#FFFFFF') {
            setSubtitleBackground('#FFFFFF');
        } else if (selectedValue === 'RGBA(0, 0, 0, 0.5)' || selectedValue === 'RGBA(0,0,0,0.5)') {
            setSubtitleBackground('rgba(0, 0, 0, 0.5)');
        } else {
            subtitleBgEnabled = true;
            subtitleBgColor = subtitleBackgroundColorPicker.value;
            drawCanvas();
        }
    });

    subtitleBackgroundColorPresets.addEventListener('change', () => {
        subtitleBackgroundColorPicker.value = subtitleBackgroundColorPresets.value;
        const color = subtitleBackgroundColorPresets.value;
        if (color === '#d41c1c' || color === '#000000' || color === '#FFFFFF') {
            setSubtitleBackground(color);
        } else {
            subtitleBgEnabled = true;
            subtitleBgColor = color;
            drawCanvas();
        }
    });

    // Gradient background swatch click handlers
    function setGradientBackground(color) {
        // Remove active class from all swatches
        Object.values(gradientBgSwatches).forEach(swatch => {
            if (swatch) swatch.classList.remove('active');
        });
        
        if (color === 'transparent') {
            gradientBgEnabled = false;
            gradientBgSwatches.transparent?.classList.add('active');
        } else {
            gradientBgEnabled = true;
            gradientBgColor = color;
            
            // Set active swatch based on color
            if (color === '#d41c1c') {
                gradientBgSwatches.red?.classList.add('active');
            } else if (color === '#000000') {
                gradientBgSwatches.black?.classList.add('active');
            } else if (color === '#0773D8') {
                gradientBgSwatches.blue?.classList.add('active');
            } else if (color === '#FF009D') {
                gradientBgSwatches.pink?.classList.add('active');
            }
        }
        drawCanvas();
    }
    
    // Add click handlers to gradient swatches
    gradientBgSwatches.transparent?.addEventListener('click', () => setGradientBackground('transparent'));
    gradientBgSwatches.red?.addEventListener('click', () => setGradientBackground('#d41c1c'));
    gradientBgSwatches.black?.addEventListener('click', () => setGradientBackground('#000000'));
    gradientBgSwatches.blue?.addEventListener('click', () => setGradientBackground('#0773D8'));
    gradientBgSwatches.pink?.addEventListener('click', () => setGradientBackground('#FF009D'));
    
    // Initialize with black selected (default)
    setGradientBackground('#000000');

    function handleFontChange() {
        const selectedFont = fontStyleSelect.value;
        if (selectedFont === 'Parkinsans') {
            subtitleColorPicker.value = '#FFF200';
            subtitleColorPresets.value = '#FFF200';
        } else if (selectedFont === 'Fira Sans') {
            subtitleColorPicker.value = '#FFFFFF';
            subtitleColorPresets.value = '#FFFFFF';
        } else if (selectedFont === 'Hanken Grotesk') {
            subtitleColorPicker.value = '#FFFFFF';
            subtitleColorPresets.value = '#FFFFFF';
        } else if (selectedFont === 'Inter') {
            subtitleColorPicker.value = '#FFFFFF';
            subtitleColorPresets.value = '#FFFFFF';
        } else if (selectedFont === 'IBM Plex Sans') {
            subtitleColorPicker.value = '#FFFFFF';
            subtitleColorPresets.value = '#FFFFFF';
        }
        for (let i = 0; i < subtitleColorPresets.options.length; i++) {
            if (subtitleColorPresets.options?.[i]?.value === subtitleColorPicker.value) {
                subtitleColorPresets.selectedIndex = i;
                break;
            }
        }
        // Force immediate redraw and ensure font is loaded
        // First, clear the canvas to remove old font rendering
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Wait for fonts to be ready, then redraw
        if (document.fonts && document.fonts.ready) {
            document.fonts.ready.then(() => {
                // Force a complete redraw
                drawCanvas();
            }).catch(() => {
                // If fonts API fails, redraw immediately
                drawCanvas();
            });
        } else {
            // Fallback: small delay to ensure font loads, then redraw
            setTimeout(() => {
                drawCanvas();
            }, 100);
        }
    }
    
    // Add both change and input event listeners to catch all font changes
    fontStyleSelect.addEventListener('change', handleFontChange);
    fontStyleSelect.addEventListener('input', handleFontChange);

    function hexToRgb(hex) {
        const bigint = parseInt(hex.slice(1), 16);
        const r = (bigint >> 16) & 255;
        const g = (bigint >> 8) & 255;
        const b = bigint & 255;
        return [r, g, b];
    }

    /**
     * Applies French typography rules:
     * - Prevents articles (un, une, les, des, du, de la, l') from being separated from their nouns.
     * - Prevents monosyllabic prepositions (√†, de, ou, et, etc.) from being alone at the end of a line.
     * Achieved by replacing regular spaces with non-breaking spaces (\u00A0)
     * and for l', replacing the standard apostrophe with a non-breaking apostrophe (\u202F).
     * @param {string} text The input text.
     * @returns {string} The text with non-breaking spaces applied for French typography.
     */
    function applyFrenchTypographyRules(text) {
        // Monosyllabic prepositions and articles (add more if needed)
        const monosyllabicWords = [
            'a', '√†', 'aux', 'au', 'dans', 'de', 'des', 'du', 'd√®s', 'en', 'et', 'le', 'la', 'les',
            'ou', 'o√π', 'par', 'pour', 'que', 'qui', 'sa', 'se', 'ses', 'son', 'sous', 'sur', 'un', 'une', 'vers'
        ].join('|');

        // Regex to find these words followed by a space
        const regex = new RegExp(`\\b(${monosyllabicWords})\\s`, 'gi');

        // Replace space with non-breaking space
        let processedText = text.replace(regex, (match, p1) => {
            return p1 + '\u00A0'; // Non-breaking space
        });

        // Special handling for 'l'' to use non-breaking apostrophe
        // Ensure apostrophes (like in "aujourd'hui") also use non-breaking space if followed by a space
        // This regex captures 'word' + "'" + 'space' or 'l' + "'" + 'space'
        processedText = processedText.replace(/(\b\w)'\s/g, (match, p1) => {
            if (p1.toLowerCase() === 'l') {
                return 'l\u202F'; // Non-breaking apostrophe for l'
            }
            return p1 + '\u0027\u00A0'; // Standard apostrophe + non-breaking space for others
        });

        return processedText;
    }

    /**
     * Formats the current date in French format (DayName Day MonthName Year)
     * @returns {string} The formatted date string (e.g., "www.lemauricien.com  ‚Ä∫ Jeudi 15 Janvier 2026")
     */
    function getFrenchDate() {
        const now = new Date();
        const days = ['Dimanche', 'Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi'];
        const months = ['Janvier', 'F√©vrier', 'Mars', 'Avril', 'Mai', 'Juin', 
                       'Juillet', 'Ao√ªt', 'Septembre', 'Octobre', 'Novembre', 'D√©cembre'];
        const dayName = days[now.getDay()];
        const day = now.getDate();
        const monthName = months[now.getMonth()];
        const year = now.getFullYear();
        return `LEMAURICIEN.COM  ‚Ä∫ ${dayName} ${day} ${monthName} ${year}`;
    }

    function drawCanvas() {
      // Clear canvas completely to prevent font persistence
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // Reset canvas state to ensure clean font rendering
      ctx.font = 'normal normal normal 12px sans-serif';

      // Determine font families and weights based on selection
      const selectedFont = fontStyleSelect.value;
      let subtitleFontFamily, titleFontFamily;
      let subtitleWeight;
      let titleWeight;
      let fontStyle = 'normal'; // Default font style

      // Get the current title size input value
      let titleSize = parseInt(titleSizeInput.value); // Keep this to allow user override
      
      // Get title weight from dropdown
      titleWeight = titleWeightSelect.value;


      switch (selectedFont) {
        case 'Parkinsans':
          subtitleFontFamily = 'Parkinsans';
          titleFontFamily = 'Parkinsans';
          subtitleWeight = '600';
          break;
        case 'Hanken Grotesk':
          subtitleFontFamily = '"Hanken Grotesk"';
          titleFontFamily = '"Hanken Grotesk"';
          subtitleWeight = '600';
          break;
        case 'Inter':
          subtitleFontFamily = '"Inter"';
          titleFontFamily = '"Inter"';
          subtitleWeight = '600';
          break;
        case 'IBM Plex Sans':
          subtitleFontFamily = '"IBM Plex Sans"';
          titleFontFamily = '"IBM Plex Sans"';
          subtitleWeight = '600';
          break;
        case 'Fira Sans':
        default:
          subtitleFontFamily = 'Fira Sans';
          titleFontFamily = 'Fira Sans';
          subtitleWeight = '700';
          break;
      }

      if (uploadedImage) {
        const imgRatio = uploadedImage.width / uploadedImage.height;
        const canvasRatio = canvas.width / canvas.height;

        let mainImgX = 0, mainImgY = 0, mainImgW = canvas.width, mainImgH = canvas.height;

        // Calculate base dimensions for cover/contain
        if (imageCoverMode) { // Cover mode (image fills frame, no blur needed behind)
          if (imgRatio > canvasRatio) { // Image is wider, match canvas height
            mainImgH = canvas.height;
            mainImgW = mainImgH * imgRatio;
          } else { // Image is taller, match canvas width
            mainImgW = canvas.width;
            mainImgH = mainImgW / imgRatio;
          }
        } else { // Fit to Frame (Contain) mode (image is smaller, blur needed behind)
          if (imgRatio < canvasRatio) { // Image is narrower, match canvas height
            mainImgH = canvas.height;
            mainImgW = mainImgH * imgRatio;
          } else { // Image is wider, match canvas width
            mainImgW = canvas.width;
            mainImgH = mainImgW / imgRatio;
          }
        }

        // Apply zoom
        const zoomFactor = currentImageZoom / 100;
        mainImgW *= zoomFactor;
        mainImgH *= zoomFactor;

        // Center the image before applying offsets
        mainImgX = (canvas.width - mainImgW) / 2;
        mainImgY = (canvas.height - mainImgH) / 2;

        // Apply user offsets
        mainImgX += currentImageOffsetX;
        mainImgY += currentImageOffsetY;

        // --- BLURRED BACKGROUND IMAGE (ONLY FOR FIT TO FRAME MODE) ---
        if (!imageCoverMode) { // If it's NOT cover mode, it's fit mode, so apply blur
            ctx.save();
            ctx.filter = 'blur(30px)'; // Apply blur to the background layer
            
            let blurImgW, blurImgH;
            const blurImgRatio = uploadedImage.width / uploadedImage.height;
            const blurCanvasRatio = canvas.width / canvas.height;

            // This ensures the blurred background always 'covers' the entire canvas,
            // even if the main image is in 'fit' mode.
            if (blurImgRatio > blurCanvasRatio) {
                blurImgH = canvas.height;
                blurImgW = blurImgH * blurImgRatio;
            } else {
                blurImgW = canvas.width;
                blurImgH = blurImgW / blurImgRatio;
            }

            blurImgW *= zoomFactor;
            blurImgH *= zoomFactor;

            const blurX = (canvas.width - blurImgW) / 2 + currentImageOffsetX;
            const blurY = (canvas.height - blurImgH) / 2 + currentImageOffsetY;


            ctx.drawImage(uploadedImage, blurX, blurY, blurImgW, blurImgH);
            ctx.filter = 'none'; // Reset filter
            ctx.restore();
        }

        // --- MAIN IMAGE (NO BLUR) ---
        ctx.drawImage(uploadedImage, mainImgX, mainImgY, mainImgW, mainImgH);

        // --- OVERLAY ---
        ctx.fillStyle = 'rgba(0,0,0,0.1)'; // Slight dark overlay
        ctx.fillRect(0, 0, canvas.width, canvas.height);

      } else {
        ctx.fillStyle = '#4a5568';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#a0aec0';
        ctx.font = "700 36px 'Fira Sans', sans-serif"; // Still default font for placeholder
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText("Drag & Drop, Click to Upload, or Paste Image", canvas.width / 2, canvas.height / 2);
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        return;
      }

      // ML Info logo: Position based on format (calculated after text processing)

      // Apply French typography rules to title and subtitle
      const titleRaw = applyFrenchTypographyRules(titleInput.value.trim());
      const subtitleRaw = applyFrenchTypographyRules(subtitleInput.value.trim().toUpperCase());

      const placement = parseInt(placementInput.value);
      // titleSize is now set dynamically at the top of the function
      const subtitleSizeAdj = parseInt(subtitleSizeInput.value);
      // subtitleBgEnabled and subtitleBgColor are now managed by swatch selection
      const subtitleTextColor = subtitleColorPicker.value;

      // Adjusted padding for subtitle background
      const paddingLeft = 20; // Increased left padding
      const paddingRight = 20;
      const paddingTop = 15;
      const paddingBottom = 8;

      const borderRadius = 10;

      const maxTextWidth = canvas.width - 160; // Reduced from 200 to 160 (20px less padding on each side)

      let subtitleLines = [];
      // Apply fontStyle to subtitle
      ctx.font = `${fontStyle} ${subtitleWeight} ${subtitleSizeAdj}px ${subtitleFontFamily}, sans-serif`;
      // Splitting by regular space still works for initial word wrapping logic, as non-breaking spaces are handled by ctx.measureText
      const subtitleWords = subtitleRaw.split(' ');
      let currentSubtitleLine = '';
      for (let word of subtitleWords) {
          const testLine = currentSubtitleLine + word + ' ';
          if (ctx.measureText(testLine).width > maxTextWidth && currentSubtitleLine !== '') {
              subtitleLines.push(currentSubtitleLine.trim());
              currentSubtitleLine = word + ' ';
          } else {
              currentSubtitleLine = testLine;
          }
      }
      if (currentSubtitleLine) subtitleLines.push(currentSubtitleLine.trim());

      if (subtitleLines.length > 2) {
          subtitleLines = subtitleLines.slice(0, 2);
          // Re-evaluate '...' length with the actual font
          // Apply fontStyle to subtitle for '...' measurement
          ctx.font = `${fontStyle} ${subtitleWeight} ${subtitleSizeAdj}px ${subtitleFontFamily}, sans-serif`;
          if (ctx.measureText(subtitleLines?.[1] + "\u2026").width < maxTextWidth) { // Use U+2026 HORIZONTAL ELLIPSIS
              subtitleLines[1] += "\u2026";
          }
      }
      const subtitleLineHeight = subtitleSizeAdj * 1.05;
      let totalSubtitleHeight = subtitleLines.length * subtitleLineHeight;

      let titleLines = [];
      function wrapTitleLines() {
        titleLines = [];
        let line = '';
        // Apply fontStyle to title
        ctx.font = `${fontStyle} ${titleWeight} ${titleSize}px ${titleFontFamily}, sans-serif`;
        // Splitting by regular space still works for initial word wrapping logic
        const words = titleRaw.split(' ');
        for (let word of words) {
          const test = line + word + ' ';
          if (ctx.measureText(test).width > maxTextWidth && line !== '') {
            titleLines.push(line.trim());
            line = word + ' ';
          } else {
            line = test;
          }
        }
        if (line) titleLines.push(line.trim());
        return titleLines.length;
      }

      // Allow up to 8 lines for the title (doubled from 4 since length limit doubled to 400), scaling down from initial 120px, but not below 36px
      while (wrapTitleLines() > 8 && titleSize > 36) { 
        titleSize -= 2;
        // Ensure titleSize does not go below the minimum set in the input field
        if (titleSize < parseInt(titleSizeInput.min)) {
            titleSize = parseInt(titleSizeInput.min);
            break;
        }
      }

      const updatedTitleLineHeight = titleSize * 1.05;

      let textBlockHeight = 0;
      if (subtitleLines.length > 0) {
          textBlockHeight += totalSubtitleHeight;
          if (subtitleBgEnabled) {
              textBlockHeight += (paddingTop + paddingBottom);
          }
          textBlockHeight += 12; // Space between subtitle block and title
      }
      textBlockHeight += titleLines.length * updatedTitleLineHeight;
      textBlockHeight += 50; // Additional bottom padding for subtitle and title block

      // Adjust placement map based on format
      let placementMap;
      if (currentFormat === 'website') {
        // Website format: matches watermarker.html positioning
        placementMap = {
          1: { x: 30, align: 'left', y: 50 }, // Top Left with 30px padding (reduced from 50px)
          3: { x: 30, align: 'left', y: 0 },
          5: { x: canvas.width / 2, align: 'center', y: 50 }, // Top Center with 50px padding
          6: { x: canvas.width / 2, align: 'center', y: 0 }
        };
      } else {
        // Social format: standard positioning
        placementMap = {
          1: { x: 80, align: 'left', y: 150 }, // Top Left with 80px padding (reduced from 100px)
          3: { x: 80, align: 'left', y: 0 },
          5: { x: canvas.width / 2, align: 'center', y: 150 }, // Top Center with 150px padding
          6: { x: canvas.width / 2, align: 'center', y: 0 }
        };
      }

      let posX = placementMap?.[placement]?.x ?? (currentFormat === 'website' ? 30 : 80);
      let align = placementMap?.[placement]?.align ?? 'left';
      
      // Calculate vertical position using slider, respecting padding constraints
      const topPadding = currentFormat === 'website' ? 50 : 100;
      // Adjust bottom padding based on format
      let logoHeight, logoBottomPadding, logoClearance, bottomPadding;
      if (currentFormat === 'website') {
        // Website format (1000x500): matches watermarker.html - 35px bottom + logo height (49px) + 10px clearance
        logoHeight = 49; // Matches watermarker logo height
        logoBottomPadding = 35; // Matches watermarker
        logoClearance = 10; // Reduced clearance for shorter canvas
        bottomPadding = logoHeight + logoBottomPadding + logoClearance; // 94px total
      } else {
        // Social format (1000x1250): standard padding
        logoHeight = 60;
        logoBottomPadding = 50;
        logoClearance = 50;
        bottomPadding = logoHeight + logoBottomPadding + logoClearance; // 160px total
      }
      // Allow text block to go closer to bottom - ensure bottom of block doesn't enter bottom padding area
      const maxY = canvas.height - bottomPadding - textBlockHeight;
      const minY = topPadding;
      const availableRange = Math.max(0, maxY - minY);
      
      // Keep slider max at 100 always to allow full range movement
      if (verticalPositionSlider.max !== "100") {
        verticalPositionSlider.max = "100";
      }
      
      // Get slider value (0-100) and map it to the available range
      const sliderValue = parseFloat(verticalPositionSlider.value);
      const sliderPercentage = sliderValue / 100;
      let posY = minY + (availableRange * sliderPercentage);
      
      // Ensure posY stays within bounds and bottom of text block doesn't exceed bottom padding
      posY = Math.max(minY, Math.min(maxY, posY));
      // Double-check: ensure bottom of text block (posY + textBlockHeight) doesn't exceed canvas.height - bottomPadding
      if (posY + textBlockHeight > canvas.height - bottomPadding) {
        posY = canvas.height - bottomPadding - textBlockHeight;
      }
      
      // Update display value to show actual pixel position
      verticalPositionValue.textContent = Math.round(posY);

      // Only draw title, subtitle, and gradient for social format
      if (currentFormat === 'social') {
        const gradientPadding = 150;
        let gradient;

        const selectedBlendMode = backgroundBlendMode.value;
        
        // Get color values from gradient swatch selection
        let r, g, b;
        if (gradientBgColor === 'transparent' || !gradientBgEnabled) {
          // Skip gradient drawing if transparent
          r = g = b = 0; // Will be skipped anyway
        } else if (gradientBgColor.startsWith('rgba')) {
          // Handle rgba values
          const rgbaMatch = gradientBgColor.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
          if (rgbaMatch) {
            r = parseInt(rgbaMatch[1]);
            g = parseInt(rgbaMatch[2]);
            b = parseInt(rgbaMatch[3]);
          } else {
            r = g = b = 0;
          }
        } else {
          // Handle hex values
          [r, g, b] = hexToRgb(gradientBgColor);
        }

        // Only draw gradient if enabled (not transparent)
        if (gradientBgEnabled && gradientBgColor !== 'transparent') {
          ctx.save();
          ctx.globalCompositeOperation = selectedBlendMode;

          if (placement === 1 || placement === 5) {
            const gradientEndY = posY + textBlockHeight + gradientPadding;
            gradient = ctx.createLinearGradient(0, 0, 0, gradientEndY);

            gradient.addColorStop(0, `rgba(${r},${g},${b},0.8)`);
            gradient.addColorStop(0.6, `rgba(${r},${g},${b},0.4)`);
            gradient.addColorStop(1, `rgba(${r},${g},${b},0)`);

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, gradientEndY);
          } else if (placement === 3 || placement === 6) {
            const gradientStartY = posY - gradientPadding;
            gradient = ctx.createLinearGradient(0, gradientStartY, 0, canvas.height);

            gradient.addColorStop(0, `rgba(${r},${g},${b},0)`);
            gradient.addColorStop(0.4, `rgba(${r},${g},${b},0.4)`);
            gradient.addColorStop(1, `rgba(${r},${g},${b},0.8)`);

            ctx.fillStyle = gradient;
            ctx.fillRect(0, gradientStartY, canvas.width, canvas.height - gradientStartY);
          }

          ctx.restore();
        }

        ctx.textAlign = align;
        ctx.textBaseline = 'top';
        ctx.shadowColor = 'rgba(0,0,0,0.4)';
        ctx.shadowBlur = 4;
        ctx.shadowOffsetX = 2;
        ctx.shadowOffsetY = 2;

        let currentTextY = posY;

        if (subtitleLines.length > 0) {
            // Apply fontStyle to subtitle
            ctx.font = `${fontStyle} ${subtitleWeight} ${subtitleSizeAdj}px ${subtitleFontFamily}, sans-serif`;

            let maxSubtitleLineTextWidth = 0;
            for (let line of subtitleLines) {
                maxSubtitleLineTextWidth = Math.max(maxSubtitleLineTextWidth, ctx.measureText(line).width);
            }

            let subtitleBgX = posX;
            if (align === 'center') {
                subtitleBgX -= (maxSubtitleLineTextWidth + paddingLeft + paddingRight) / 2;
            } else if (align === 'right') {
                subtitleBgX -= (maxSubtitleLineTextWidth + paddingLeft + paddingRight);
            } else { // left align
                // For left alignment, background starts at posX to align with title
                subtitleBgX = posX;
            }


            if (subtitleBgEnabled) {
                ctx.fillStyle = subtitleBgColor;
                const bgWidth = maxSubtitleLineTextWidth + paddingLeft + paddingRight;
                const bgY = currentTextY - paddingTop; // Adjusted for new paddingTop
                const bgHeight = totalSubtitleHeight + (paddingTop + paddingBottom); // Adjusted for new paddings

                ctx.beginPath();
                ctx.moveTo(subtitleBgX + borderRadius, bgY);
                ctx.lineTo(subtitleBgX + bgWidth - borderRadius, bgY);
                ctx.quadraticCurveTo(subtitleBgX + bgWidth, bgY, subtitleBgX + bgWidth, bgY + borderRadius);
                ctx.lineTo(subtitleBgX + bgWidth, bgY + bgHeight - borderRadius);
                ctx.quadraticCurveTo(subtitleBgX + bgWidth, bgY + bgHeight, subtitleBgX + bgWidth - borderRadius, bgY + bgHeight);
                ctx.lineTo(subtitleBgX + borderRadius, bgY + bgHeight);
                ctx.quadraticCurveTo(subtitleBgX, bgY + bgHeight, subtitleBgX, bgY + bgHeight - borderRadius);
                ctx.lineTo(subtitleBgX, bgY + borderRadius);
                ctx.quadraticCurveTo(subtitleBgX, bgY, subtitleBgX + borderRadius, bgY);
                ctx.closePath();
                ctx.fill();
            }

            ctx.fillStyle = subtitleTextColor;
            // When left-aligned and background is enabled, push text inside by paddingLeft
            for (let i = 0; i < subtitleLines.length; i++) {
                // For left alignment with background, add paddingLeft to align text inside background
                const textX = (align === 'left' && subtitleBgEnabled) ? posX + paddingLeft : posX;
                ctx.fillText(subtitleLines[i], textX, currentTextY + i * subtitleLineHeight);
            }
            currentTextY += totalSubtitleHeight;

            if (subtitleBgEnabled) {
                currentTextY += (paddingTop + paddingBottom); // Advance Y by full background height
            }
            currentTextY += 12; // Space between subtitle block and title
        }

        ctx.fillStyle = 'white';
        // Apply fontStyle to title
        ctx.font = `${fontStyle} ${titleWeight} ${titleSize}px ${titleFontFamily}, sans-serif`;
        
        // Get kerning value
        const kerning = parseFloat(kerningSlider.value);
        
        // Draw title lines with kerning
        for (let i = 0; i < titleLines.length; i++) {
          const line = titleLines?.[i] ?? '';
          const yPos = currentTextY + i * updatedTitleLineHeight;
          
          if (kerning === 0) {
            // No kerning needed
            ctx.fillText(line, posX, yPos);
          } else if (typeof ctx.letterSpacing !== 'undefined') {
            // Use letterSpacing if supported (modern browsers)
            ctx.letterSpacing = `${kerning}px`;
            ctx.fillText(line, posX, yPos);
            ctx.letterSpacing = '0px'; // Reset
          } else {
            // Fallback: draw characters individually with spacing
            let xPos = posX;
            for (let j = 0; j < line.length; j++) {
              ctx.fillText(line[j], xPos, yPos);
              const charWidth = ctx.measureText(line[j]).width;
              xPos += charWidth + kerning;
            }
          }
        }

        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
      }

      // Turf Logo: Top right (if enabled) - positioned below date stamp with clearance
      if (turfLogoToggle.checked && turfLogoLoaded) {
          const turfLogoHeight = 100;
          const turfLogoWidth = turfLogo.width * (turfLogoHeight / turfLogo.height);
          const turfLogoX = canvas.width - turfLogoWidth - 50; // 50px padding from right (same as date)
          const turfLogoY = 100; // Top padding, positioned below date stamp (date is at y=50)
          ctx.drawImage(turfLogo, turfLogoX, turfLogoY, turfLogoWidth, turfLogoHeight);
      }

      // ML Info logo: Position based on format
      if (mlinfoLogoLoaded) {
        let mlinfoLogoHeight, mlinfoLogoWidth, mlinfoLogoX, mlinfoLogoY;
        if (currentFormat === 'website') {
          // Website format: matches watermarker.html - left side, 50px from left, 35px from bottom, 49px height
          mlinfoLogoHeight = 49;
          mlinfoLogoWidth = mlinfoLogo.width * (mlinfoLogoHeight / mlinfoLogo.height);
          mlinfoLogoX = 50; // Left padding (matches watermarker)
          mlinfoLogoY = canvas.height - mlinfoLogoHeight - 35; // 35px padding from bottom (matches watermarker)
        } else {
          // Social format: Center bottom, height 60px, padding 50px from bottom
          mlinfoLogoHeight = 60;
          mlinfoLogoWidth = mlinfoLogo.width * (mlinfoLogoHeight / mlinfoLogo.height);
          mlinfoLogoX = (canvas.width - mlinfoLogoWidth) / 2; // Center horizontally
          mlinfoLogoY = canvas.height - mlinfoLogoHeight - 50; // 50px padding from bottom
        }
        ctx.drawImage(mlinfoLogo, mlinfoLogoX, mlinfoLogoY, mlinfoLogoWidth, mlinfoLogoHeight);
      }

      // --- DATE STAMP (Top Right) - On top layer - Only for social format ---
      if (currentFormat === 'social') {
        ctx.save();
        ctx.font = '400 24px "Inter", sans-serif'; // Small, light font (increased from 22px to 24px)
        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)'; // Transparent white
        ctx.textAlign = 'right';
        ctx.textBaseline = 'top';
        ctx.shadowColor = 'rgba(0, 0, 0, 0.3)'; // Subtle shadow for readability
        ctx.shadowBlur = 2;
        ctx.shadowOffsetX = 1;
        ctx.shadowOffsetY = 1;
        const dateText = getFrenchDate();
        ctx.fillText(dateText, canvas.width - 50, 50); // 50px padding from right, 50px from top
        ctx.restore();
      }
    }

    function downloadImage() {
      const buttonContainer = document.querySelector('.flex.gap-3.pt-4');
      const downloadButton = buttonContainer.querySelector('button:last-child');
      const generateButton = buttonContainer.querySelector('button:first-child');
      const importButton = document.querySelector('.import-button');

      const originalDownloadText = downloadButton.textContent;
      downloadButton.textContent = 'Downloading...';
      downloadButton.disabled = true;
      generateButton.disabled = true;
      importButton.disabled = true;

      try {
        const link = document.createElement('a');
        const formatName = currentFormat === 'social' ? 'social-media' : 'website';
        link.download = `${formatName}-image.webp`;
        link.href = canvas.toDataURL('image/webp', 0.8);

        link.click();

        setTimeout(() => {
          downloadButton.textContent = originalDownloadText;
          downloadButton.disabled = false;
          generateButton.disabled = false;
          importButton.disabled = false;
        }, 2000);
      } catch (error) {
        console.error("Download failed:", error);
        alert("Image download failed. Please try again.");
        downloadButton.textContent = originalDownloadText;
        downloadButton.disabled = false;
        generateButton.disabled = false;
        importButton.disabled = false;
      }
    }

    window.onload = () => {
        subtitleInput.value = ""; // Empty subtitle field
        titleInput.value = ""; // Empty title field

        // Set default values
        titleSizeInput.value = "70";
        subtitleSizeInput.value = "40";
        titleWeightSelect.value = "600";
        kerningSlider.value = "-2";
        kerningValue.textContent = "-2";
        placementInput.value = "3"; // Bottom Left
        verticalPositionSlider.value = "100"; // Maximum (bottom)
        titleSizeInput.setAttribute("max", "140");

        // Initialize format (social by default)
        currentFormat = 'social';
        updateCanvasSize();
        
        drawCanvas();
        // Manually trigger the font style change to set initial subtitle color correctly
        fontStyleSelect.dispatchEvent(new Event('change'));
    };
  </script>
</body>
</html>