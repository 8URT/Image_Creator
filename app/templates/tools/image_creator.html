<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Social Media Image Creator</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Fira+Sans:wght@400;500;600;700;800;900&display=swap" rel="stylesheet" />
  <link href="https://fonts.googleapis.com/css2?family=Parkinsans:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Hanken+Grotesk:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Noto+Serif:ital,wght@0,400;0,700;1,200;1,400&display=swap" rel="stylesheet">

  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    // Template configuration from server
    const templateConfig = {{ template_config | tojson }};
  </script>

  <style>
    :root {
      --cool-steel: #8399a2;
      --cool-steel-2: #95a8b0;
      --cool-steel-3: #a7b7bd;
      --silver: #b9c6cb;
      --silver-2: #cad4d8;
      --alabaster-grey: #dce3e6;
      --platinum: #eef2f3;
    }
    
    /* Minimalist Design with Cool Steel Palette */
    body {
      background-color: var(--platinum);
      color: var(--cool-steel);
      font-weight: 300;
    }
    .gradient-bg {
      background: var(--platinum);
    }
    .bg-white {
      background-color: #ffffff;
      color: var(--cool-steel);
    }
    .text-gray-800 {
      color: var(--cool-steel);
      font-weight: 400;
    }
    .border-gray-200 {
      border-color: var(--silver-2);
    }
    .border-gray-300 {
      border-color: var(--silver);
    }
    .border-gray-400 {
      border-color: var(--cool-steel-3);
    }
    .text-gray-600 {
      color: var(--cool-steel-2);
      font-weight: 400;
    }
    .text-gray-500 {
      color: var(--cool-steel-3);
    }
    .bg-gray-100 {
      background-color: var(--alabaster-grey);
      color: var(--cool-steel);
    }
    .bg-gray-200 {
      background-color: var(--alabaster-grey);
    }
    .hover\:bg-gray-200:hover {
      background-color: var(--silver-2);
    }
    .hover\:bg-gray-300:hover {
      background-color: var(--silver);
    }
    .text-blue-600 {
      color: var(--cool-steel);
    }
    .focus\:border-blue-500 {
      border-color: var(--cool-steel-2);
    }
    .focus\:ring-blue-100 {
      box-shadow: 0 0 0 1px var(--cool-steel-3);
    }
    .hover\:border-blue-500 {
      border-color: var(--cool-steel-2);
    }
    .hover\:bg-blue-50 {
      background-color: var(--alabaster-grey);
    }
    /* Minimalist buttons */
    .import-button, .generate-button {
      background: var(--cool-steel);
      color: #ffffff;
      border: 1px solid var(--cool-steel);
      font-weight: 500;
    }
    .import-button:hover, .generate-button:hover {
      background: var(--cool-steel-2);
      border-color: var(--cool-steel-2);
      transform: translateY(-1px);
    }
    .download-button {
      background: var(--silver);
      color: var(--cool-steel);
      border: 1px solid var(--silver);
      font-weight: 500;
    }
    .download-button:hover {
      background: var(--cool-steel-3);
      border-color: var(--cool-steel-3);
      transform: translateY(-1px);
    }
    .process-button {
      background: var(--cool-steel);
      color: #ffffff;
      border: 1px solid var(--cool-steel);
      font-weight: 500;
    }
    .process-button:hover {
      background: var(--cool-steel-2);
      border-color: var(--cool-steel-2);
      transform: translateY(-1px);
    }
    .ring-blue-500 {
      box-shadow: 0 0 0 3px rgba(102, 170, 255, 0.5);
    }

    /* Minimalist Image Size Mode button */
    #imageSizeMode {
        background: var(--alabaster-grey);
        color: var(--cool-steel);
        border: 1px solid var(--silver-2);
        outline: none;
        font-weight: 500;
        transition: all 0.2s ease;
    }
    #imageSizeMode:hover {
        background: var(--silver-2);
        border-color: var(--silver);
        transform: translateY(-1px);
    }

    /* Canvas specific styles */
    #canvas {
      max-width: 100%;
      height: auto;
      background-color: #ffffff;
      border: 1px solid var(--silver-2);
    }

    /* Style for the drag-over state */
    .drag-over {
        border-color: var(--cool-steel) !important;
        background-color: var(--alabaster-grey) !important;
        color: var(--cool-steel) !important;
    }

    /* Range slider minimalist styles */
    input[type="range"] {
        background-color: var(--alabaster-grey);
    }
    input[type="range"]::-webkit-slider-thumb {
      background: var(--cool-steel);
      border: 1px solid var(--cool-steel-2);
    }
    input[type="range"]::-moz-range-thumb {
      background: var(--cool-steel);
      border: 1px solid var(--cool-steel-2);
    }
    input[type="range"]::-ms-thumb {
      background: var(--cool-steel);
      border: 1px solid var(--cool-steel-2);
    }
    /* Input field background and text */
    input[type="text"], input[type="number"], textarea, select {
      background-color: #ffffff;
      color: var(--cool-steel);
      border-color: var(--silver);
      font-weight: 400;
    }
    input[type="text"]::placeholder, textarea::placeholder {
      color: var(--cool-steel-3);
    }
    /* Minimalist drop zone */
    #imageDropZone {
        background: var(--alabaster-grey);
        border-color: var(--silver);
        border-width: 2px;
    }
    #imageDropZone:hover {
        border-color: var(--cool-steel-2);
        background: var(--silver-2);
        transform: translateY(-1px);
    }
    /* Minimalist format button styles */
    .format-button {
      background: var(--alabaster-grey);
      color: var(--cool-steel);
      border: 1px solid var(--silver-2);
      font-weight: 500;
    }
    .subtitle-bg-swatch.active {
      border-color: var(--cool-steel) !important;
      border-width: 2px !important;
    }
    .gradient-bg-swatch.active {
      border-color: var(--cool-steel) !important;
      border-width: 2px !important;
    }
    .format-button:hover {
      background: var(--silver-2);
      border-color: var(--silver);
    }
    #formatSocial.active {
      background: #457b9d;
      border-color: #457b9d;
      color: #ffffff;
    }
    #formatWebsite.active {
      background: #e63946;
      border-color: #e63946;
      color: #ffffff;
    }
    #quoteModeToggle.active {
      background: #006d77;
      border-color: #006d77;
      color: #ffffff;
    }
    #bulkModeToggle.active {
      background: #7209b7;
      border-color: #7209b7;
      color: #ffffff;
    }
    
    /* Navigation Menu */
    .top-nav {
      height: 70px;
      background-color: #8399a2;
      position: sticky;
      top: 0;
      z-index: 100;
      padding-top: 15px;
    }
    .nav-container {
      display: flex;
      align-items: center;
      justify-content: space-between;
      width: 100%;
    }
    .nav-left {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .nav-logo {
      height: 40px;
      width: auto;
    }
    .nav-title {
      font-size: 18px;
      font-weight: 500;
      color: #ffffff;
      margin: 0;
    }
    .nav-right {
      display: flex;
      align-items: center;
      gap: 16px;
    }
    .nav-icon-button {
      width: 40px;
      height: 40px;
      border-radius: 6px;
      border: 1px solid rgba(255, 255, 255, 0.3);
      background-color: rgba(255, 255, 255, 0.1);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s ease;
      color: #ffffff;
    }
    .nav-icon-button:hover {
      background-color: rgba(255, 255, 255, 0.2);
      border-color: rgba(255, 255, 255, 0.5);
    }
    .nav-icon-button svg {
      width: 20px;
      height: 20px;
    }

    /* Mobile Responsiveness - Only applies to screens <= 768px */
    @media (max-width: 768px) {
      /* Navigation Menu Mobile Adjustments */
      .top-nav {
        height: 60px;
        padding-top: 12px;
      }
      .nav-logo {
        height: 32px;
      }
      .nav-title {
        font-size: 16px;
      }
      .nav-icon-button {
        width: 36px;
        height: 36px;
      }
      .nav-icon-button svg {
        width: 18px;
        height: 18px;
      }
      .max-w-5xl.mx-auto.px-4 {
        padding-left: 8px;
        padding-right: 8px;
      }

      /* Touch Target Optimization */
      button, .nav-icon-button, .subtitle-bg-swatch, .gradient-bg-swatch {
        min-height: 44px;
      }
      input[type="range"]::-webkit-slider-thumb {
        width: 20px;
        height: 20px;
      }
      input[type="range"]::-moz-range-thumb {
        width: 20px;
        height: 20px;
      }
      input[type="range"]::-ms-thumb {
        width: 20px;
        height: 20px;
      }

      /* Prevent horizontal scroll */
      body {
        overflow-x: hidden;
      }

      /* Canvas container mobile optimization */
      .flex.justify-center.items-start {
        padding: 8px 0;
      }

      /* Ensure canvas scales properly on mobile */
      #canvas {
        width: 100%;
        height: auto;
      }
    }
  </style>
</head>
<body class="min-h-screen gradient-bg font-['Fira_Sans']">
  <!-- Top Navigation Menu -->
  <nav class="top-nav">
    <div class="max-w-5xl mx-auto px-4 w-full">
      <div class="nav-container">
        <div class="nav-left">
          <img src="{{ url_for('static', filename='assets/mlinfo_lm.png') }}" alt="Logo" class="nav-logo">
          <h1 class="nav-title">Image creator</h1>
        </div>
        <div class="nav-right">
          {% if current_user.is_authenticated and current_user.is_admin %}
          <a href="{{ url_for('admin.users') }}" class="nav-icon-button" title="Admin Panel">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
            </svg>
          </a>
          {% endif %}
          <a href="{{ url_for('auth.logout') }}" class="nav-icon-button" title="Logout">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1" />
            </svg>
          </a>
        </div>
      </div>
    </div>
  </nav>

  <div class="max-w-5xl mx-auto px-4 pt-4 sm:pt-8 pb-4">

    <div class="rounded-lg overflow-hidden">
      <div class="grid lg:grid-cols-[1fr_320px] gap-2 sm:gap-4 p-2 sm:p-4">
        <div class="flex justify-center items-start">
          <canvas id="canvas" width="1000" height="1250" class="rounded shadow-sm bg-white"></canvas>
        </div>

        <div class="bg-white p-3 sm:p-5 rounded-lg shadow-sm border border-gray-200">
          <div class="mb-4">
            <div class="flex gap-2 mb-2">
              <button type="button" id="formatSocial" class="flex-1 px-4 py-3 sm:py-2 rounded font-bold transition-all duration-300 text-sm format-button active" data-format="social">
                Social Image
              </button>
              <button type="button" id="formatWebsite" class="flex-1 px-4 py-3 sm:py-2 rounded font-bold transition-all duration-300 text-sm format-button" data-format="website">
                Website Image
              </button>
            </div>
            <div class="flex gap-2">
              <button type="button" id="quoteModeToggle" class="flex-1 px-4 py-3 sm:py-2 rounded font-bold transition-all duration-300 text-sm format-button" data-mode="quote">
                Quote Mode
              </button>
              <button type="button" id="bulkModeToggle" class="flex-1 px-4 py-3 sm:py-2 rounded font-bold transition-all duration-300 text-sm format-button" data-mode="bulk">
                Bulk Mode
              </button>
            </div>
          </div>

          <div id="imageDropZone" onclick="document.getElementById('imageUpload').click()" class="border-2 border-dashed border-gray-400 rounded p-4 sm:p-8 text-center mb-4 transition-all duration-300 cursor-pointer hover:border-gray-500 hover:shadow-sm hover:-translate-y-1 flex flex-col items-center justify-center min-h-[120px]">
              <input type="file" id="imageUpload" accept="image/*" class="hidden" />
              <p id="dropZoneText" class="text-base sm:text-lg font-bold text-gray-600 mb-3">Select, Drop or Paste your Image</p>
              <button type="button" id="bulkSelectButton" onclick="event.stopPropagation(); document.getElementById('imageUpload').click();" class="import-button text-white px-4 py-3 sm:py-2 rounded font-bold transition-all duration-300 hover:-translate-y-1 text-sm hidden">
                or Click to Select Images
              </button>
          </div>

          <button type="button" id="imageSizeMode" class="w-full px-4 py-3 sm:py-2 mb-4 rounded font-bold transition-all duration-300 hover:-translate-y-1 text-sm">
            Fill Frame (Cover)
          </button>

          <div id="imagePositionControls" class="mb-4">
            <div class="grid grid-cols-2 sm:grid-cols-4 gap-2 sm:gap-3 mb-4">
              <div>
                <label for="imageOffsetX" class="block font-bold text-gray-600 mb-1 text-xs text-center">
                  ‚Üê ‚Üí
                </label>
                <input type="range" id="imageOffsetX" min="-500" max="500" value="0" class="w-full h-2 bg-gray-200 rounded appearance-none cursor-pointer">
              </div>
              <div>
                <label for="imageOffsetY" class="block font-bold text-gray-600 mb-1 text-xs text-center">
                  ‚Üë ‚Üì
                </label>
                <input type="range" id="imageOffsetY" min="-500" max="500" value="0" class="w-full h-2 bg-gray-200 rounded appearance-none cursor-pointer">
              </div>
              <div>
                <label for="imageZoom" class="block font-bold text-gray-600 mb-1 text-xs text-center">
                  - üîç +
                </label>
                <input type="range" id="imageZoom" min="1" max="300" value="100" class="w-full h-2 bg-gray-200 rounded appearance-none cursor-pointer">
              </div>
              <div class="flex items-end">
                <button type="button" id="resetImageControls" class="w-full h-8 flex items-center justify-center bg-gray-200 hover:bg-gray-300 rounded transition-all duration-300 cursor-pointer" title="Reset to defaults">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-gray-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                  </svg>
                </button>
              </div>
            </div>
          </div>

          <!-- Quote Mode Portrait Section -->
          <div id="quoteModeSection" class="mb-4 hidden">
            <div id="portraitPositionControls" class="mb-4 hidden">
              <label class="block font-bold text-gray-600 mb-1 text-xs">Portrait Position:</label>
              <div class="grid grid-cols-2 sm:grid-cols-4 gap-2 sm:gap-3 mb-4">
                <div>
                  <label for="portraitPositionX" class="block font-bold text-gray-600 mb-1 text-xs text-center">
                    ‚Üê ‚Üí
                  </label>
                  <input type="range" id="portraitPositionX" min="-1000" max="1000" value="200" class="w-full h-2 bg-gray-200 rounded appearance-none cursor-pointer">
                </div>
                <div>
                  <label for="portraitPositionY" class="block font-bold text-gray-600 mb-1 text-xs text-center">
                    ‚Üë ‚Üì
                  </label>
                  <input type="range" id="portraitPositionY" min="-1000" max="1000" value="100" class="w-full h-2 bg-gray-200 rounded appearance-none cursor-pointer">
                </div>
                <div>
                  <label for="portraitZoom" class="block font-bold text-gray-600 mb-1 text-xs text-center">
                    - üîç +
                  </label>
                  <input type="range" id="portraitZoom" min="1" max="300" value="100" class="w-full h-2 bg-gray-200 rounded appearance-none cursor-pointer">
                </div>
                <div class="flex items-end">
                  <button type="button" id="resetPortraitControls" class="w-full h-8 flex items-center justify-center bg-gray-200 hover:bg-gray-300 rounded transition-all duration-300 cursor-pointer" title="Reset to defaults">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-gray-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                    </svg>
                  </button>
                </div>
              </div>
            </div>

            <div id="portraitAdjustmentControls" class="mb-4 hidden">
              <label class="block font-bold text-gray-600 mb-1 text-xs">Portrait Image Adjustments:</label>
              <div class="grid grid-cols-2 sm:grid-cols-4 gap-2 sm:gap-3 mb-4">
                <div>
                  <label for="portraitPanX" class="block font-bold text-gray-600 mb-1 text-xs text-center">
                    ‚Üê ‚Üí
                  </label>
                  <input type="range" id="portraitPanX" min="-500" max="500" step="1" value="0" class="w-full h-2 bg-gray-200 rounded appearance-none cursor-pointer">
                </div>
                <div>
                  <label for="portraitPanY" class="block font-bold text-gray-600 mb-1 text-xs text-center">
                    ‚Üë ‚Üì
                  </label>
                  <input type="range" id="portraitPanY" min="-500" max="500" step="1" value="0" class="w-full h-2 bg-gray-200 rounded appearance-none cursor-pointer">
                </div>
                <div>
                  <label for="portraitImageZoom" class="block font-bold text-gray-600 mb-1 text-xs text-center">
                    - üîç +
                  </label>
                  <input type="range" id="portraitImageZoom" min="1" max="1000" step="1" value="100" class="w-full h-2 bg-gray-200 rounded appearance-none cursor-pointer">
                </div>
                <div class="flex items-end">
                  <button type="button" id="resetPortraitImageControls" class="w-full h-8 flex items-center justify-center bg-gray-200 hover:bg-gray-300 rounded transition-all duration-300 cursor-pointer" title="Reset to defaults">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-gray-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                    </svg>
                  </button>
                </div>
              </div>
            </div>
          </div>

          <!-- Bulk Mode Section -->
          <div id="bulkModeSection" class="mb-4 hidden">
            <div class="mb-4">
              <h3 class="text-md font-bold text-gray-600 mb-2 text-xs">Output Settings:</h3>
              <div class="flex flex-col gap-2">
                <label class="inline-flex items-center text-gray-600 text-sm">
                  <input type="radio" name="outputSize" value="original" checked class="form-radio text-blue-600 h-4 w-4" />
                  <span class="ml-2">Original Size & Ratio (Max 2000px edge)</span>
                </label>
                <label class="inline-flex items-center text-gray-600 text-sm">
                  <input type="radio" name="outputSize" value="compressed" class="form-radio text-blue-600 h-4 w-4" />
                  <span class="ml-2">Compressed (Max 1920px longest edge, 80% quality)</span>
                </label>
              </div>
            </div>

            <div class="space-y-4">
              <div id="bulkProcessingStatus" class="text-center text-sm text-gray-600 font-medium hidden">
                <p id="bulkProcessedCountText">0/0 images processed</p>
              </div>

              <div class="flex flex-col gap-3 pt-4">
                <button id="processImagesButton" onclick="processSelectedFiles()" class="process-button text-white px-4 py-3 sm:py-2 rounded font-bold transition-all duration-300 hover:-translate-y-1 hover:shadow-sm text-sm" disabled>
                  Process Images
                </button>
                <button id="downloadAllButton" onclick="downloadAllImages()" class="download-button text-white px-4 py-3 sm:py-2 rounded font-bold transition-all duration-300 hover:-translate-y-1 hover:shadow-sm text-sm hidden">
                  Download All Watermarked
                </button>
              </div>
            </div>
          </div>

          <div class="space-y-4 mb-4">
            <div>
              <input type="text" id="subtitle" placeholder="Subtitle in caps" maxlength="60" class="w-full px-3 py-2 border border-gray-300 rounded focus:border-blue-500 focus:ring-1 focus:ring-blue-100 transition-all duration-300 text-sm" />
            </div>

            <div>
              <textarea id="title" rows="3" placeholder="Main title here..." maxlength="400" class="w-full px-3 py-2 border border-gray-300 rounded focus:border-blue-500 focus:ring-1 focus:ring-blue-100 transition-all duration-300 resize-y min-h-[60px] text-sm"></textarea>
            </div>

            <div>
              <label class="block font-bold text-gray-600 mb-1 text-xs">
                Text Block Vertical Position: <span id="verticalPositionValue">100</span>px
              </label>
              <input type="range" id="verticalPositionSlider" min="0" max="100" value="100" step="1" class="w-full h-2 bg-gray-200 rounded appearance-none cursor-pointer slider" />
            </div>
          </div>

          <div class="space-y-4">
            <div>
                <select id="fontStyleSelect" class="w-full px-3 py-2 border border-gray-300 rounded focus:border-blue-500 focus:ring-1 focus:ring-blue-100 transition-all duration-300 text-sm">
                    <option value="Fira Sans">Font: Fira Sans (Default)</option>
                    <option value="Parkinsans">Font: Parkinsans (Magazine)</option>
                    <option value="Hanken Grotesk">Font: Hanken Grotesk</option>
                    <option value="Inter" selected>Font: Inter</option>
                    <option value="IBM Plex Sans">Font: IBM Plex Sans</option>
                    <option value="Noto Serif">Font: Noto Serif</option>
                </select>
            </div>

            <div class="grid grid-cols-2 gap-2">
              <div>
                <label class="block font-bold text-gray-600 mb-1 text-xs">Title Size (px):</label>
                <input type="number" id="titleSize" value="70" min="36" max="140" placeholder="Title size" inputmode="numeric" class="w-full px-3 py-2 border border-gray-300 rounded focus:border-blue-500 focus:ring-1 focus:ring-blue-100 transition-all duration-300 text-sm" />
              </div>
              <div>
                <label class="block font-bold text-gray-600 mb-1 text-xs">Subtitle Size (px):</label>
                <input type="number" id="subtitleSize" value="40" min="20" max="80" placeholder="Subtitle size" inputmode="numeric" class="w-full px-3 py-2 border border-gray-300 rounded focus:border-blue-500 focus:ring-1 focus:ring-blue-100 transition-all duration-300 text-sm" />
              </div>
            </div>

            <div>
              <select id="placement" class="w-full px-3 py-2 border border-gray-300 rounded focus:border-blue-500 focus:ring-1 focus:ring-blue-100 transition-all duration-300 text-sm">
                <option value="1">Alignment: Top Left</option>
                <option value="3" selected>Alignment: Bottom Left</option>
                <option value="5">Alignment: Top Center</option>
                <option value="6">Alignment: Bottom Center</option>
              </select>
            </div>

            <div class="grid grid-cols-2 gap-2 sm:gap-3 mt-2 mb-2">
              <div>
                <label class="block font-bold text-gray-600 mb-1 text-xs">Subtitle Background:</label>
                <div class="flex gap-1 items-center">
                  <button type="button" id="subtitleBgTransparent" class="subtitle-bg-swatch w-6 h-6 sm:w-5 sm:h-5 border-2 border-gray-400 rounded cursor-pointer hover:border-blue-500 transition-all" style="background: repeating-conic-gradient(#808080 0% 25%, #c0c0c0 0% 50%) 50% / 8px 8px;" title="Transparent" data-color="transparent"></button>
                  <button type="button" id="subtitleBgRed" class="subtitle-bg-swatch w-6 h-6 sm:w-5 sm:h-5 border-2 border-gray-400 rounded cursor-pointer hover:border-blue-500 transition-all bg-[#d41c1c]" title="Red" data-color="#d41c1c"></button>
                  <button type="button" id="subtitleBgBlack" class="subtitle-bg-swatch w-6 h-6 sm:w-5 sm:h-5 border-2 border-gray-400 rounded cursor-pointer hover:border-blue-500 transition-all bg-black" title="Black" data-color="#000000"></button>
                  <button type="button" id="subtitleBgWhite" class="subtitle-bg-swatch w-6 h-6 sm:w-5 sm:h-5 border-2 border-gray-400 rounded cursor-pointer hover:border-blue-500 transition-all bg-white" title="White" data-color="#FFFFFF"></button>
                  <button type="button" id="subtitleBgDarkGrey" class="subtitle-bg-swatch w-6 h-6 sm:w-5 sm:h-5 border-2 border-gray-400 rounded cursor-pointer hover:border-blue-500 transition-all" style="background: rgba(0, 0, 0, 0.5);" title="Black 50% Opacity" data-color="rgba(0, 0, 0, 0.5)"></button>
                </div>
              </div>

              <div>
                <label class="block font-bold text-gray-600 mb-1 text-xs">Gradient Shadow:</label>
                <div class="flex gap-1 items-center">
                  <button type="button" id="gradientBgTransparent" class="gradient-bg-swatch w-6 h-6 sm:w-5 sm:h-5 border-2 border-gray-400 rounded cursor-pointer hover:border-blue-500 transition-all" style="background: repeating-conic-gradient(#808080 0% 25%, #c0c0c0 0% 50%) 50% / 8px 8px;" title="Transparent" data-color="transparent"></button>
                  <button type="button" id="gradientBgRed" class="gradient-bg-swatch w-6 h-6 sm:w-5 sm:h-5 border-2 border-gray-400 rounded cursor-pointer hover:border-blue-500 transition-all bg-[#d41c1c]" title="Red" data-color="#d41c1c"></button>
                  <button type="button" id="gradientBgBlack" class="gradient-bg-swatch w-6 h-6 sm:w-5 sm:h-5 border-2 border-gray-400 rounded cursor-pointer hover:border-blue-500 transition-all bg-black" title="Black" data-color="#000000"></button>
                  <button type="button" id="gradientBgBlue" class="gradient-bg-swatch w-6 h-6 sm:w-5 sm:h-5 border-2 border-gray-400 rounded cursor-pointer hover:border-blue-500 transition-all" style="background: #0773D8;" title="Blue" data-color="#0773D8"></button>
                  <button type="button" id="gradientBgPink" class="gradient-bg-swatch w-6 h-6 sm:w-5 sm:h-5 border-2 border-gray-400 rounded cursor-pointer hover:border-blue-500 transition-all" style="background: #FF009D;" title="Pink" data-color="#FF009D"></button>
                </div>
              </div>
            </div>

            <div class="mt-4 mb-2">
              <button type="button" id="advancedOptionsToggle" class="w-full px-3 py-3 sm:py-2 bg-gray-100 hover:bg-gray-200 border border-gray-300 rounded font-bold text-gray-700 transition-all duration-300 text-sm flex items-center justify-center">
                <span>Advanced Options</span>
                <svg id="advancedOptionsIcon" xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 ml-2 transition-transform duration-300" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" />
                </svg>
              </button>
            </div>

            <div id="advancedOptions" class="space-y-4 hidden">
            <div>
              <label class="block font-bold text-gray-600 mb-1 text-xs">Title Font Weight:</label>
              <select id="titleWeightSelect" class="w-full px-3 py-2 border border-gray-300 rounded focus:border-blue-500 focus:ring-1 focus:ring-blue-100 transition-all duration-300 text-sm">
                <option value="400">400 (Regular)</option>
                <option value="500">500 (Medium)</option>
                <option value="600" selected>600 (Semi Bold)</option>
                <option value="700">700 (Bold)</option>
                <option value="800">800 (Extra Bold)</option>
                <option value="900">900 (Black)</option>
              </select>
            </div>

            <div>
              <label class="block font-bold text-gray-600 mb-1 text-xs">
                Title Kerning: <span id="kerningValue">-2</span>px
              </label>
              <input type="range" id="kerningSlider" min="-2" max="0" value="-2" step="0.5" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer slider" />
            </div>

            <div class="grid grid-cols-2 gap-2">
                <div>
                    <label class="block font-bold text-gray-600 mb-1 text-xs">Subtitle Color:</label>
                    <div class="flex gap-2">
                        <input type="color" id="subtitleColorPicker" value="#FFFFFF" class="w-1/2 h-8 border-2 border-gray-300 rounded-md cursor-pointer" />
                        <select id="subtitleColorPresets" class="w-1/2 px-2 py-1 border border-gray-300 rounded focus:border-blue-500 focus:ring-1 focus:ring-blue-100 transition-all duration-300 text-sm">
                            <option value="#FFFFFF" selected>White</option>
                            <option value="#000000">Black</option>
                            <option value="#FFF200">Cool Yellow</option>
                            <option value="#00BFFF">Deep Sky Blue</option>
                        </select>
                    </div>
                </div>
            </div>

            <div class="grid grid-cols-2 gap-2">
                <div class="col-span-2">
                    <label class="block font-bold text-gray-600 mb-1 text-xs">Subtitle Background Color:</label>
                    <div class="flex gap-2">
                        <input type="color" id="subtitleBackgroundColorPicker" value="#d41c1c" class="w-1/2 h-8 border-2 border-gray-300 rounded-md cursor-pointer" />
                        <select id="subtitleBackgroundColorPresets" class="w-1/2 px-2 py-1 border border-gray-300 rounded focus:border-blue-500 focus:ring-1 focus:ring-blue-100 transition-all duration-300 text-sm">
                            <option value="#d41c1c" selected>Default Red</option>
                            <option value="#000000">Black</option>
                            <option value="#FFFFFF">White</option>
                        </select>
                    </div>
                </div>
            </div>

            <div>
                <label class="block font-bold text-gray-600 mb-1 text-xs">Background Blend Mode:</label>
                <select id="backgroundBlendMode" class="w-full px-3 py-2 border border-gray-300 rounded focus:border-blue-500 focus:ring-1 focus:ring-100 transition-all duration-300 text-sm">
                    <option value="source-over" selected>Normal</option>
                    <option value="multiply">Multiply</option>
                    <option value="screen">Screen</option>
                    <option value="overlay">Overlay</option>
                    <option value="darken">Darken</option>
                    <option value="lighten">Lighten</option>
                </select>
            </div>

            <div class="flex items-center">
              <input type="checkbox" id="turfLogoToggle" class="mr-2 h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded" />
              <label for="turfLogoToggle" class="block font-bold text-gray-600 text-xs">Show Turf Logo</label>
            </div>
            </div>

            <div class="flex gap-3 pt-4">
              <button onclick="drawCanvas()" class="generate-button flex-1 text-white px-4 py-3 sm:py-2 rounded font-bold transition-all duration-300 hover:-translate-y-1 hover:shadow-sm text-sm">Generate Image</button>
              <button onclick="downloadImage()" class="download-button flex-1 text-white px-4 py-3 sm:py-2 rounded font-bold transition-all duration-300 hover:-translate-y-1 hover:shadow-sm text-sm">Download Image</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const imageInput = document.getElementById('imageUpload');
    const titleInput = document.getElementById('title');
    const subtitleInput = document.getElementById('subtitle');
    const placementInput = document.getElementById('placement');
    const titleSizeInput = document.getElementById('titleSize');
    const subtitleSizeInput = document.getElementById('subtitleSize');
    const titleWeightSelect = document.getElementById('titleWeightSelect');
    const kerningSlider = document.getElementById('kerningSlider');
    const kerningValue = document.getElementById('kerningValue');
    const verticalPositionSlider = document.getElementById('verticalPositionSlider');
    const verticalPositionValue = document.getElementById('verticalPositionValue');
    const subtitleColorPicker = document.getElementById('subtitleColorPicker');
    const subtitleColorPresets = document.getElementById('subtitleColorPresets');

    const subtitleBackgroundColorPicker = document.getElementById('subtitleBackgroundColorPicker');
    const subtitleBackgroundColorPresets = document.getElementById('subtitleBackgroundColorPresets');
    
    // Subtitle background swatch elements
    const subtitleBgSwatches = {
      transparent: document.getElementById('subtitleBgTransparent'),
      red: document.getElementById('subtitleBgRed'),
      black: document.getElementById('subtitleBgBlack'),
      white: document.getElementById('subtitleBgWhite'),
      darkGrey: document.getElementById('subtitleBgDarkGrey')
    };
    
    // Track subtitle background state
    let subtitleBgEnabled = false;
    let subtitleBgColor = '#d41c1c'; // Default red (but transparent is default)

    const backgroundBlendMode = document.getElementById('backgroundBlendMode');
    
    // Gradient background swatch elements
    const gradientBgSwatches = {
      transparent: document.getElementById('gradientBgTransparent'),
      red: document.getElementById('gradientBgRed'),
      black: document.getElementById('gradientBgBlack'),
      blue: document.getElementById('gradientBgBlue'),
      pink: document.getElementById('gradientBgPink')
    };
    
    // Track gradient background color state
    let gradientBgColor = '#000000'; // Default black
    let gradientBgEnabled = true; // Gradient is always enabled (transparent just means no gradient)

    const imageSizeModeButton = document.getElementById('imageSizeMode');
    let imageCoverMode = true; // Changed default to Cover, as per button text

    const imageOffsetXInput = document.getElementById('imageOffsetX');
    const imageOffsetYInput = document.getElementById('imageOffsetY');
    const imageZoomInput = document.getElementById('imageZoom');
    const resetImageControls = document.getElementById('resetImageControls');

    let currentImageOffsetX = 0;
    let currentImageOffsetY = 0;
    let currentImageZoom = 100;

    const fontStyleSelect = document.getElementById('fontStyleSelect');
    const turfLogoToggle = document.getElementById('turfLogoToggle');
    const formatSocial = document.getElementById('formatSocial');
    const formatWebsite = document.getElementById('formatWebsite');

    // Format state: 'social' or 'website'
    let currentFormat = 'social';
    const SOCIAL_FORMAT = { width: 1000, height: 1250 };
    const WEBSITE_FORMAT = { width: 1000, height: 500 };

    // Quote Mode state
    const quoteModeToggle = document.getElementById('quoteModeToggle');
    let quoteModeEnabled = false;
    let uploadedPortraitImage = null;

    // Bulk Mode state
    const bulkModeToggle = document.getElementById('bulkModeToggle');
    let bulkModeEnabled = false;
    let filesToProcess = [];
    let processedImages = [];
    let currentProcessedCount = 0;
    let currentOutputSetting = 'original';
    
    // Portrait position controls (circle position on canvas)
    let portraitPositionX = 200; // Default: 200px from left
    let portraitPositionY = 100; // Default: 100px from top
    let portraitZoom = 100; // Circle size zoom (1-300, default 100)
    
    // Portrait image adjustment controls (image within circle)
    let portraitImageZoom = 100; // Image zoom within circle (1-500, default 100)
    let portraitPanX = 0; // Image pan X within circle
    let portraitPanY = 0; // Image pan Y within circle
    
    const portraitPositionXInput = document.getElementById('portraitPositionX');
    const portraitPositionYInput = document.getElementById('portraitPositionY');
    const portraitZoomInput = document.getElementById('portraitZoom');
    const portraitImageZoomInput = document.getElementById('portraitImageZoom');
    const portraitPanXInput = document.getElementById('portraitPanX');
    const portraitPanYInput = document.getElementById('portraitPanY');
    const resetPortraitControls = document.getElementById('resetPortraitControls');
    const resetPortraitImageControls = document.getElementById('resetPortraitImageControls');
    
    const quoteModeSection = document.getElementById('quoteModeSection');
    const portraitPositionControls = document.getElementById('portraitPositionControls');
    const portraitAdjustmentControls = document.getElementById('portraitAdjustmentControls');

    // Bulk Mode elements
    const bulkModeSection = document.getElementById('bulkModeSection');
    const bulkProcessingStatus = document.getElementById('bulkProcessingStatus');
    const bulkProcessedCountText = document.getElementById('bulkProcessedCountText');
    const processImagesButton = document.getElementById('processImagesButton');
    const downloadAllButton = document.getElementById('downloadAllButton');
    const outputSizeRadios = document.querySelectorAll('input[name="outputSize"]');

    // Watermark logos for bulk mode
    const watermarkLogo = new Image();
    watermarkLogo.src = '{{ url_for("static", filename="assets/logo.png") }}';
    let watermarkLogoLoaded = false;
    watermarkLogo.onload = () => {
      watermarkLogoLoaded = true;
    };
    watermarkLogo.onerror = () => {
      console.warn("Watermark logo (logo.png) failed to load.");
      watermarkLogoLoaded = false;
    };

    // Asset 2 no longer needed - only using logo.png for bottom watermark (same as social image)

    let uploadedImage = null;

    const turfLogo = new Image();
    turfLogo.src = '{{ url_for("static", filename="assets/turf_logo.png") }}';
    let turfLogoLoaded = false;
    turfLogo.onload = () => {
      turfLogoLoaded = true;
      drawCanvas();
    };
    turfLogo.onerror = () => {
      console.warn("Turf logo (turf_logo.png) failed to load.");
      turfLogoLoaded = false;
      drawCanvas();
    };

    const mlinfoLogo = new Image();
    mlinfoLogo.src = '{{ url_for("static", filename="assets/mlinfo_lm.png") }}';
    let mlinfoLogoLoaded = false;
    mlinfoLogo.onload = () => {
      mlinfoLogoLoaded = true;
      drawCanvas();
    };
    mlinfoLogo.onerror = () => {
      console.warn("ML Info logo (mlinfo_lm.png) failed to load.");
      mlinfoLogoLoaded = false;
      drawCanvas();
    };

    // Top right logo for social images (mlinfo.png)
    const mlinfoTopRightLogo = new Image();
    mlinfoTopRightLogo.src = '{{ url_for("static", filename="assets/mlinfo.png") }}';
    let mlinfoTopRightLogoLoaded = false;
    mlinfoTopRightLogo.onload = () => {
      mlinfoTopRightLogoLoaded = true;
      drawCanvas();
    };
    mlinfoTopRightLogo.onerror = () => {
      console.warn("ML Info top right logo (mlinfo.png) failed to load.");
      mlinfoTopRightLogoLoaded = false;
      drawCanvas();
    };

    // Top right logo for quote mode (quotes.png)
    const quotesLogo = new Image();
    quotesLogo.src = '{{ url_for("static", filename="assets/quotes.png") }}';
    let quotesLogoLoaded = false;
    quotesLogo.onload = () => {
      quotesLogoLoaded = true;
      drawCanvas();
    };
    quotesLogo.onerror = () => {
      console.warn("Quotes logo (quotes.png) failed to load.");
      quotesLogoLoaded = false;
      drawCanvas();
    };

    function handlePaste(e) {
      const items = e.clipboardData?.items;
      if (!items) return;

      for (let item of items) {
        if (item.type.startsWith('image/')) {
          e.preventDefault();
          const file = item.getAsFile();
          if (file) {
            if (bulkModeEnabled) {
              // In bulk mode, add to files to process
              handleFiles([file]);
            } else {
              loadImageFromFile(file);
            }
          }
          break;
        }
      }
    }

    function loadImageFromFile(file) {
      if (!file.type.startsWith('image/')) {
        alert("Please upload an image file (e.g., JPEG, PNG, GIF).");
        return;
      }

      const reader = new FileReader();
      reader.onload = () => {
        const img = new Image();
        img.onload = () => {
          uploadedImage = img;
          // If quote mode is enabled, also set as portrait
          if (quoteModeEnabled) {
            uploadedPortraitImage = img;
            portraitPositionControls.classList.remove('hidden');
            portraitAdjustmentControls.classList.remove('hidden');
            // Reset portrait image adjustments when new image is loaded
            portraitImageZoom = 100;
            portraitPanX = 0;
            portraitPanY = 0;
            if (portraitImageZoomInput) portraitImageZoomInput.value = 100;
            if (portraitPanXInput) portraitPanXInput.value = 0;
            if (portraitPanYInput) portraitPanYInput.value = 0;
          }
          resetImageTransforms();
          drawCanvas();
        };
        img.onerror = () => {
          alert("Could not load image. Please try another file.");
          uploadedImage = null;
          if (quoteModeEnabled) {
            uploadedPortraitImage = null;
            portraitPositionControls.classList.add('hidden');
            portraitAdjustmentControls.classList.add('hidden');
          }
          drawCanvas();
        };
        img.src = reader.result;
      };
      reader.readAsDataURL(file);
    }

    function loadPortraitImageFromFile(file) {
      if (!file.type.startsWith('image/')) {
        alert("Please upload an image file (e.g., JPEG, PNG, GIF) for the portrait.");
        return;
      }

      const reader = new FileReader();
      reader.onload = () => {
        const img = new Image();
        img.onload = () => {
          uploadedPortraitImage = img;
          // Also set the portrait as the background image (will be blurred)
          uploadedImage = img;
          portraitPositionControls.classList.remove('hidden');
          portraitAdjustmentControls.classList.remove('hidden');
          // Reset portrait image adjustments when new image is loaded (position stays at defaults)
          portraitImageZoom = 100;
          portraitPanX = 0;
          portraitPanY = 0;
          if (portraitImageZoomInput) portraitImageZoomInput.value = 100;
          if (portraitPanXInput) portraitPanXInput.value = 0;
          if (portraitPanYInput) portraitPanYInput.value = 0;
          // Reset main image transforms to show full blurred background
          resetImageTransforms();
          drawCanvas();
        };
        img.onerror = () => {
          alert("Could not load portrait image. Please try another file.");
          uploadedPortraitImage = null;
          portraitPositionControls.classList.add('hidden');
          portraitAdjustmentControls.classList.add('hidden');
          drawCanvas();
        };
        img.src = reader.result;
      };
      reader.readAsDataURL(file);
    }

    document.addEventListener('paste', handlePaste);
    document.getElementById('imageDropZone').addEventListener('paste', handlePaste);
    document.getElementById('imageDropZone').setAttribute('tabindex', '0');

    const imageDropZone = document.getElementById('imageDropZone');
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
      imageDropZone.addEventListener(eventName, preventDefaults, false);
      document.body.addEventListener(eventName, preventDefaults, false);
    });

    function preventDefaults (e) {
      e.preventDefault();
      e.stopPropagation();
    }

    ['dragenter', 'dragover'].forEach(eventName => {
      imageDropZone.addEventListener(eventName, highlight, false);
    });

    ['dragleave', 'drop'].forEach(eventName => {
      imageDropZone.addEventListener(eventName, unhighlight, false);
    });

    function highlight() {
      imageDropZone.classList.add('drag-over');
    }

    function unhighlight() {
      imageDropZone.classList.remove('drag-over');
    }

    imageDropZone.addEventListener('drop', handleDrop, false);

    function handleDrop(e) {
      const dt = e.dataTransfer;
      const files = dt.files;

      if (files.length > 0) {
        if (bulkModeEnabled) {
          handleFiles(files);
        } else {
          loadImageFromFile(files?.[0]);
        }
      }
    }

    imageInput.addEventListener('change', (e) => {
      if (bulkModeEnabled) {
        if (e.target.files && e.target.files.length > 0) {
          handleFiles(e.target.files);
        } else {
          resetBulkUI();
        }
      } else {
        const file = e.target.files?.[0];
        if (!file) {
          uploadedImage = null;
          drawCanvas();
          return;
        }
        loadImageFromFile(file);
      }
    });


    // Portrait position slider event listeners
    if (portraitPositionXInput) {
      portraitPositionXInput.addEventListener('input', (e) => {
        portraitPositionX = parseFloat(e.target.value);
        drawCanvas();
      });
    }

    if (portraitPositionYInput) {
      portraitPositionYInput.addEventListener('input', (e) => {
        portraitPositionY = parseFloat(e.target.value);
        drawCanvas();
      });
    }

    if (portraitZoomInput) {
      portraitZoomInput.addEventListener('input', (e) => {
        portraitZoom = parseFloat(e.target.value);
        drawCanvas();
      });
    }

    // Portrait image adjustment slider event listeners
    if (portraitImageZoomInput) {
      portraitImageZoomInput.addEventListener('input', (e) => {
        portraitImageZoom = parseFloat(e.target.value);
        drawCanvas();
      });
    }

    if (portraitPanXInput) {
      portraitPanXInput.addEventListener('input', (e) => {
        portraitPanX = parseFloat(e.target.value);
        drawCanvas();
      });
    }

    if (portraitPanYInput) {
      portraitPanYInput.addEventListener('input', (e) => {
        portraitPanY = parseFloat(e.target.value);
        drawCanvas();
      });
    }

    // Reset portrait position controls
    if (resetPortraitControls) {
      resetPortraitControls.addEventListener('click', () => {
        portraitPositionX = 200;
        portraitPositionY = 100;
        portraitZoom = 100;
        if (portraitPositionXInput) portraitPositionXInput.value = 200;
        if (portraitPositionYInput) portraitPositionYInput.value = 100;
        if (portraitZoomInput) portraitZoomInput.value = 100;
        drawCanvas();
      });
    }

    // Reset portrait image adjustment controls
    if (resetPortraitImageControls) {
      resetPortraitImageControls.addEventListener('click', () => {
        portraitImageZoom = 100;
        portraitPanX = 0;
        portraitPanY = 0;
        if (portraitImageZoomInput) portraitImageZoomInput.value = 100;
        if (portraitPanXInput) portraitPanXInput.value = 0;
        if (portraitPanYInput) portraitPanYInput.value = 0;
        drawCanvas();
      });
    }

    ([
      titleInput, subtitleInput, placementInput,
      titleSizeInput, subtitleSizeInput, titleWeightSelect, kerningSlider, verticalPositionSlider,
      turfLogoToggle,
      subtitleBackgroundColorPicker, subtitleBackgroundColorPresets,
      backgroundBlendMode,
      imageOffsetXInput, imageOffsetYInput, imageZoomInput
    ]).forEach(el => {
      if (el) el.addEventListener('input', drawCanvas);
    });
    
    turfLogoToggle.addEventListener('change', drawCanvas);
    
    // Advanced Options toggle
    const advancedOptionsToggle = document.getElementById('advancedOptionsToggle');
    const advancedOptions = document.getElementById('advancedOptions');
    const advancedOptionsIcon = document.getElementById('advancedOptionsIcon');
    
    advancedOptionsToggle.addEventListener('click', () => {
      const isHidden = advancedOptions.classList.contains('hidden');
      if (isHidden) {
        advancedOptions.classList.remove('hidden');
        advancedOptionsIcon.style.transform = 'rotate(180deg)';
      } else {
        advancedOptions.classList.add('hidden');
        advancedOptionsIcon.style.transform = 'rotate(0deg)';
      }
    });
    
    // Format toggle handlers
    formatSocial.addEventListener('click', () => {
      currentFormat = 'social';
      formatSocial.classList.add('active');
      formatWebsite.classList.remove('active');
      
      // Disable Quote Mode and Bulk Mode
      if (quoteModeEnabled) {
        quoteModeEnabled = false;
        quoteModeToggle.classList.remove('active');
        quoteModeSection.classList.add('hidden');
        // Hide all quote mode controls
        const portraitPositionControls = document.getElementById('portraitPositionControls');
        if (portraitPositionControls) portraitPositionControls.classList.add('hidden');
        const portraitAdjustmentControls = document.getElementById('portraitAdjustmentControls');
        if (portraitAdjustmentControls) portraitAdjustmentControls.classList.add('hidden');
        // Clear portrait image
        uploadedPortraitImage = null;
        // Show Fill Frame button and main image controls
        if (imageSizeModeButton) imageSizeModeButton.style.display = '';
        if (document.getElementById('imagePositionControls')) {
          document.getElementById('imagePositionControls').style.display = '';
        }
        // Clear quote mode state from localStorage before refresh
        localStorage.removeItem('quoteModeEnabled');
        // Save target format (social) to localStorage
        localStorage.setItem('targetFormat', 'social');
        // Refresh page when switching from quote mode to social
        window.location.reload();
        return;
      }
      if (bulkModeEnabled) {
        bulkModeEnabled = false;
        bulkModeToggle.classList.remove('active');
        bulkModeSection.classList.add('hidden');
        // Show all image creator controls
        const controlsToShow = [
          'imageSizeMode',
          'imagePositionControls',
          'subtitle',
          'title',
          'fontStyleSelect',
          'titleSize',
          'subtitleSize',
          'placement',
          'verticalPositionSlider',
          'advancedOptionsToggle'
        ];
        controlsToShow.forEach(id => {
          const el = document.getElementById(id);
          if (el) el.style.display = '';
        });
        // Show format buttons
        if (formatSocial) formatSocial.style.display = '';
        if (formatWebsite) formatWebsite.style.display = '';
        // Show generate/download buttons
        const buttonContainer = document.querySelector('.flex.gap-3.pt-4');
        if (buttonContainer) buttonContainer.style.display = '';
        // Remove multiple attribute from image input
        if (imageInput) imageInput.removeAttribute('multiple');
        // Restore drop zone text and hide bulk button
        const dropZoneText = document.getElementById('dropZoneText');
        if (dropZoneText) dropZoneText.textContent = 'Select, Drop or Paste your Image';
        const bulkSelectButton = document.getElementById('bulkSelectButton');
        if (bulkSelectButton) bulkSelectButton.classList.add('hidden');
        // Reset bulk state
        filesToProcess = [];
        processedImages = [];
        currentProcessedCount = 0;
      }
      
      updateCanvasSize();
      // Reset transforms to maintain image proportions when switching formats
      resetImageTransforms();
      // Force redraw to recalculate image dimensions for new canvas size
      drawCanvas();
    });

    formatWebsite.addEventListener('click', () => {
      currentFormat = 'website';
      formatWebsite.classList.add('active');
      formatSocial.classList.remove('active');
      
      // Disable Quote Mode and Bulk Mode
      if (quoteModeEnabled) {
        quoteModeEnabled = false;
        quoteModeToggle.classList.remove('active');
        quoteModeSection.classList.add('hidden');
        // Hide all quote mode controls
        const portraitPositionControls = document.getElementById('portraitPositionControls');
        if (portraitPositionControls) portraitPositionControls.classList.add('hidden');
        const portraitAdjustmentControls = document.getElementById('portraitAdjustmentControls');
        if (portraitAdjustmentControls) portraitAdjustmentControls.classList.add('hidden');
        // Clear portrait image
        uploadedPortraitImage = null;
        // Show Fill Frame button and main image controls
        if (imageSizeModeButton) imageSizeModeButton.style.display = '';
        if (document.getElementById('imagePositionControls')) {
          document.getElementById('imagePositionControls').style.display = '';
        }
        // Clear quote mode state from localStorage before refresh
        localStorage.removeItem('quoteModeEnabled');
        // Save target format (website) to localStorage
        localStorage.setItem('targetFormat', 'website');
        // Refresh page when switching from quote mode to website
        window.location.reload();
        return;
      }
      if (bulkModeEnabled) {
        bulkModeEnabled = false;
        bulkModeToggle.classList.remove('active');
        bulkModeSection.classList.add('hidden');
        // Show all image creator controls
        const controlsToShow = [
          'imageSizeMode',
          'imagePositionControls',
          'subtitle',
          'title',
          'fontStyleSelect',
          'titleSize',
          'subtitleSize',
          'placement',
          'verticalPositionSlider',
          'advancedOptionsToggle'
        ];
        controlsToShow.forEach(id => {
          const el = document.getElementById(id);
          if (el) el.style.display = '';
        });
        // Show format buttons
        if (formatSocial) formatSocial.style.display = '';
        if (formatWebsite) formatWebsite.style.display = '';
        // Show generate/download buttons
        const buttonContainer = document.querySelector('.flex.gap-3.pt-4');
        if (buttonContainer) buttonContainer.style.display = '';
        // Remove multiple attribute from image input
        if (imageInput) imageInput.removeAttribute('multiple');
        // Restore drop zone text and hide bulk button
        const dropZoneText = document.getElementById('dropZoneText');
        if (dropZoneText) dropZoneText.textContent = 'Select, Drop or Paste your Image';
        const bulkSelectButton = document.getElementById('bulkSelectButton');
        if (bulkSelectButton) bulkSelectButton.classList.add('hidden');
        // Reset bulk state
        filesToProcess = [];
        processedImages = [];
        currentProcessedCount = 0;
      }
      
      updateCanvasSize();
      // Reset transforms to maintain image proportions when switching formats
      resetImageTransforms();
      // Force redraw to recalculate image dimensions for new canvas size
      drawCanvas();
    });

    // Quote Mode toggle handler
    quoteModeToggle.addEventListener('click', () => {
      quoteModeEnabled = !quoteModeEnabled;
      if (quoteModeEnabled) {
        quoteModeToggle.classList.add('active');
        quoteModeSection.classList.remove('hidden');
        
        // Disable format buttons (Social/Website) - they stay visible but inactive
        formatSocial.classList.remove('active');
        formatWebsite.classList.remove('active');
        
        // Disable Bulk Mode if it's enabled (mutually exclusive)
        if (bulkModeEnabled) {
          bulkModeEnabled = false;
          bulkModeToggle.classList.remove('active');
          bulkModeSection.classList.add('hidden');
          // Restore image creator controls
          const controlsToShow = [
            'imageDropZone',
            'imageSizeMode',
            'imagePositionControls',
            'subtitle',
            'title',
            'fontStyleSelect',
            'titleSize',
            'subtitleSize',
            'placement',
            'verticalPositionSlider',
            'advancedOptionsToggle'
          ];
          controlsToShow.forEach(id => {
            const el = document.getElementById(id);
            if (el) el.style.display = '';
          });
          if (formatSocial) formatSocial.style.display = '';
          if (formatWebsite) formatWebsite.style.display = '';
          const buttonContainer = document.querySelector('.flex.gap-3.pt-4');
          if (buttonContainer) buttonContainer.style.display = '';
          if (imageInput) imageInput.removeAttribute('multiple');
          const dropZoneText = document.querySelector('#imageDropZone p');
          if (dropZoneText) dropZoneText.textContent = 'Select, Drop or Paste your Image';
          
          // Complete canvas refresh when switching from Bulk Mode to Quote Mode
          // Clear any processed images from bulk mode
          processedImages = [];
          filesToProcess = [];
          currentProcessedCount = 0;
          // Reset uploaded images
          uploadedImage = null;
          uploadedPortraitImage = null;
          // Reset canvas to default size for current format
          updateCanvasSize();
          // Clear canvas completely
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          // Reset canvas state
          ctx.font = 'normal normal normal 12px sans-serif';
          // Reset image transforms
          resetImageTransforms();
        }
        
        // Set Noto Serif as default font when quote mode is enabled
        if (fontStyleSelect && fontStyleSelect.value !== 'Noto Serif') {
          fontStyleSelect.value = 'Noto Serif';
        }
        // Set default placement to top left (1) when quote mode is enabled
        if (placementInput) {
          placementInput.value = "1";
        }
        // Set default vertical position to 400px when quote mode is enabled
        // Calculate slider value for 400px position
        if (verticalPositionSlider) {
          // For quote mode, we'll set a value that represents 400px
          // We'll update this in drawCanvas, but set a reasonable default here
          verticalPositionSlider.value = "0"; // Will be overridden to 400px in drawCanvas
        }
        // Hide Fill Frame button and main image controls when quote mode is on
        if (imageSizeModeButton) imageSizeModeButton.style.display = 'none';
        if (document.getElementById('imagePositionControls')) {
          document.getElementById('imagePositionControls').style.display = 'none';
        }
        
        // Update canvas size to social format when quote mode is enabled
        updateCanvasSize();
        resetImageTransforms();
        // Save quote mode state to localStorage before refresh
        localStorage.setItem('quoteModeEnabled', 'true');
        // Refresh page when entering quote mode
        window.location.reload();
        return;
      } else {
        quoteModeToggle.classList.remove('active');
        quoteModeSection.classList.add('hidden');
        // Show Fill Frame button and main image controls when quote mode is off
        if (imageSizeModeButton) imageSizeModeButton.style.display = '';
        if (document.getElementById('imagePositionControls')) {
          document.getElementById('imagePositionControls').style.display = '';
        }
        // Re-activate the current format button
        if (currentFormat === 'social') {
          formatSocial.classList.add('active');
        } else {
          formatWebsite.classList.add('active');
        }
        
        // Update canvas size back to current format when quote mode is disabled
        updateCanvasSize();
        resetImageTransforms();
        // Clear quote mode state from localStorage before refresh
        localStorage.removeItem('quoteModeEnabled');
        // Refresh page when exiting quote mode
        window.location.reload();
        return;
      }
      drawCanvas();
    });

    // Bulk Mode toggle handler
    bulkModeToggle.addEventListener('click', () => {
      bulkModeEnabled = !bulkModeEnabled;
      if (bulkModeEnabled) {
        bulkModeToggle.classList.add('active');
        bulkModeSection.classList.remove('hidden');
        
        // Disable format buttons (Social/Website) - they stay visible but inactive
        formatSocial.classList.remove('active');
        formatWebsite.classList.remove('active');
        
        // Disable Quote Mode if it's enabled (mutually exclusive)
        if (quoteModeEnabled) {
          quoteModeEnabled = false;
          quoteModeToggle.classList.remove('active');
          quoteModeSection.classList.add('hidden');
          // Clear quote mode state from localStorage before refresh
          localStorage.removeItem('quoteModeEnabled');
          // Save target format (bulk) to localStorage
          localStorage.setItem('targetFormat', 'bulk');
          // Refresh page when switching from quote mode to bulk
          window.location.reload();
          return;
        }
        
        // Hide image creator controls (but keep drop zone visible)
        const controlsToHide = [
          'imageSizeMode',
          'imagePositionControls',
          'subtitle',
          'title',
          'fontStyleSelect',
          'placement',
          'advancedOptionsToggle',
          'advancedOptions'
        ];
        controlsToHide.forEach(id => {
          const el = document.getElementById(id);
          if (el) el.style.display = 'none';
        });
        
        // Hide specific controls: Text Block Vertical Position, Title Size, Subtitle Size
        const verticalPositionLabel = document.querySelector('label:has(#verticalPositionValue)');
        if (verticalPositionLabel && verticalPositionLabel.parentElement) {
          verticalPositionLabel.parentElement.style.display = 'none';
        }
        // Hide Title Size and Subtitle Size - hide the entire grid container
        const titleSizeInput = document.getElementById('titleSize');
        const subtitleSizeInput = document.getElementById('subtitleSize');
        if (titleSizeInput && titleSizeInput.parentElement && titleSizeInput.parentElement.parentElement) {
          // Hide the grid container that contains both inputs
          titleSizeInput.parentElement.parentElement.style.display = 'none';
        }
        // Also hide labels individually as backup
        const titleSizeLabel = document.querySelector('label[for="titleSize"]');
        if (titleSizeLabel && titleSizeLabel.parentElement) {
          titleSizeLabel.parentElement.style.display = 'none';
        }
        const subtitleSizeLabel = document.querySelector('label[for="subtitleSize"]');
        if (subtitleSizeLabel && subtitleSizeLabel.parentElement) {
          subtitleSizeLabel.parentElement.style.display = 'none';
        }
        
        // Hide subtitle background and gradient shadow section (now in a grid)
        const subtitleBgTransparent = document.getElementById('subtitleBgTransparent');
        if (subtitleBgTransparent) {
          let parent = subtitleBgTransparent.parentElement;
          while (parent && !parent.classList.contains('grid')) {
            parent = parent.parentElement;
          }
          if (parent && parent.classList.contains('grid')) {
            parent.style.display = 'none';
          }
        }
        
        // Hide Generate Image button (keep format buttons visible)
        const generateButton = document.querySelector('.generate-button');
        if (generateButton) generateButton.style.display = 'none';
        
        // Keep drop zone visible but update for bulk mode
        if (imageDropZone) {
          imageDropZone.style.display = '';
          // Update drop zone text
          const dropZoneText = document.getElementById('dropZoneText');
          if (dropZoneText) dropZoneText.textContent = 'Drag & Drop multiple images here';
          // Show bulk select button
          const bulkSelectButton = document.getElementById('bulkSelectButton');
          if (bulkSelectButton) bulkSelectButton.classList.remove('hidden');
        }
        
        // Update image input to accept multiple files
        if (imageInput) imageInput.setAttribute('multiple', 'multiple');
        
        // Reset bulk UI
        resetBulkUI();
      } else {
        bulkModeToggle.classList.remove('active');
        bulkModeSection.classList.add('hidden');
        
        // Show all image creator controls
        const controlsToShow = [
          'imageDropZone',
          'imageSizeMode',
          'imagePositionControls',
          'subtitle',
          'title',
          'fontStyleSelect',
          'titleSize',
          'subtitleSize',
          'placement',
          'verticalPositionSlider',
          'advancedOptionsToggle'
        ];
        controlsToShow.forEach(id => {
          const el = document.getElementById(id);
          if (el) el.style.display = '';
        });
        
        // Show format buttons
        if (formatSocial) formatSocial.style.display = '';
        if (formatWebsite) formatWebsite.style.display = '';
        
        // Re-activate the current format button
        if (currentFormat === 'social') {
          formatSocial.classList.add('active');
        } else {
          formatWebsite.classList.add('active');
        }
        
        // Show generate/download buttons
        const buttonContainer = document.querySelector('.flex.gap-3.pt-4');
        if (buttonContainer) buttonContainer.style.display = '';
        
        // Remove multiple attribute from image input
        if (imageInput) imageInput.removeAttribute('multiple');
        
        // Restore drop zone text and hide bulk button
        const dropZoneText = document.getElementById('dropZoneText');
        if (dropZoneText) dropZoneText.textContent = 'Select, Drop or Paste your Image';
        const bulkSelectButton = document.getElementById('bulkSelectButton');
        if (bulkSelectButton) bulkSelectButton.classList.add('hidden');
        
        // Reset bulk state
        filesToProcess = [];
        processedImages = [];
        currentProcessedCount = 0;
      }
      drawCanvas();
    });

    function updateCanvasSize() {
      // Quote Mode always uses social format size (1000x1250)
      let format;
      if (quoteModeEnabled) {
        format = SOCIAL_FORMAT;
      } else {
        format = currentFormat === 'social' ? SOCIAL_FORMAT : WEBSITE_FORMAT;
      }
      
      // Update canvas internal dimensions (resolution)
      canvas.width = format.width;
      canvas.height = format.height;
      
      // The CSS already has max-width: 100% and height: auto which maintains aspect ratio
      // We just need to ensure the canvas element respects its natural aspect ratio
      // by not setting explicit width/height that would override the CSS
      
      // If there was an image, it will be redrawn with correct proportions in drawCanvas()
      // The image calculation in drawCanvas() uses uploadedImage.width/height which are
      // the natural dimensions, so it will maintain aspect ratio correctly
    }
    
    titleWeightSelect.addEventListener('change', drawCanvas);
    
    kerningSlider.addEventListener('input', (e) => {
      kerningValue.textContent = parseFloat(e.target.value).toFixed(1);
      drawCanvas();
    });
    
    verticalPositionSlider.addEventListener('input', (e) => {
      // The actual pixel value will be calculated in drawCanvas
      drawCanvas();
    });

    subtitleColorPicker.addEventListener('input', () => {
        const selectedValue = subtitleColorPicker.value.toUpperCase();
        let found = false;
        for (let i = 0; i < subtitleColorPresets.options.length; i++) {
            if (subtitleColorPresets.options?.[i]?.value?.toUpperCase() === selectedValue) {
                subtitleColorPresets.selectedIndex = i;
                found = true;
                break;
            }
        }
        if (!found) {
            subtitleColorPresets.selectedIndex = -1;
        }
        drawCanvas();
    });

    subtitleColorPresets.addEventListener('change', () => {
        subtitleColorPicker.value = subtitleColorPresets.value;
        drawCanvas();
    });

    imageSizeModeButton.addEventListener('click', () => {
      imageCoverMode = !imageCoverMode;
      imageSizeModeButton.textContent = imageCoverMode ? 'Fit to Frame' : 'Fill Frame (Cover)';
      resetImageTransforms();
      drawCanvas();
    });

    function resetImageTransforms() {
        currentImageOffsetX = 0;
        currentImageOffsetY = 0;
        currentImageZoom = 100;

        imageOffsetXInput.value = 0;
        imageOffsetYInput.value = 0;
        imageZoomInput.value = 100;
    }

    imageOffsetXInput.addEventListener('input', (e) => {
        currentImageOffsetX = parseInt(e.target.value);
        drawCanvas();
    });

    imageOffsetYInput.addEventListener('input', (e) => {
        currentImageOffsetY = parseInt(e.target.value);
        drawCanvas();
    });

    imageZoomInput.addEventListener('input', (e) => {
        currentImageZoom = parseInt(e.target.value);
        drawCanvas();
    });

    // Reset button functionality
    resetImageControls.addEventListener('click', () => {
        currentImageOffsetX = 0;
        currentImageOffsetY = 0;
        currentImageZoom = 100;
        
        imageOffsetXInput.value = 0;
        imageOffsetYInput.value = 0;
        imageZoomInput.value = 100;
        
        drawCanvas();
    });

    // Subtitle background swatch click handlers
    function setSubtitleBackground(color) {
        // Remove active class from all swatches
        Object.values(subtitleBgSwatches).forEach(swatch => {
            if (swatch) swatch.classList.remove('active');
        });
        
        if (color === 'transparent') {
            subtitleBgEnabled = false;
            subtitleBgSwatches.transparent?.classList.add('active');
            // Set subtitle text color to white for transparent background
            subtitleColorPicker.value = '#FFFFFF';
            subtitleColorPresets.value = '#FFFFFF';
        } else {
            subtitleBgEnabled = true;
            subtitleBgColor = color;
            subtitleBackgroundColorPicker.value = color;
            
            // Set subtitle text color based on background
            if (color === '#FFFFFF') {
                // White background -> black text
                subtitleColorPicker.value = '#000000';
                subtitleColorPresets.value = '#000000';
            } else {
                // All other colors -> white text
                subtitleColorPicker.value = '#FFFFFF';
                subtitleColorPresets.value = '#FFFFFF';
            }
            
            // Set active swatch based on color
            if (color === '#d41c1c') {
                subtitleBgSwatches.red?.classList.add('active');
            } else if (color === '#000000') {
                subtitleBgSwatches.black?.classList.add('active');
            } else if (color === '#FFFFFF') {
                subtitleBgSwatches.white?.classList.add('active');
            } else if (color === 'rgba(0, 0, 0, 0.5)' || color === 'rgba(0,0,0,0.5)') {
                subtitleBgSwatches.darkGrey?.classList.add('active');
            }
        }
        drawCanvas();
    }
    
    // Add click handlers to swatches
    subtitleBgSwatches.transparent?.addEventListener('click', () => setSubtitleBackground('transparent'));
    subtitleBgSwatches.red?.addEventListener('click', () => setSubtitleBackground('#d41c1c'));
    subtitleBgSwatches.black?.addEventListener('click', () => setSubtitleBackground('#000000'));
    subtitleBgSwatches.white?.addEventListener('click', () => setSubtitleBackground('#FFFFFF'));
    subtitleBgSwatches.darkGrey?.addEventListener('click', () => setSubtitleBackground('rgba(0, 0, 0, 0.5)'));
    
    // Initialize with transparent selected (default)
    setSubtitleBackground('transparent');

    subtitleBackgroundColorPicker.addEventListener('input', () => {
        const selectedValue = subtitleBackgroundColorPicker.value.toUpperCase();
        let found = false;
        for (let i = 0; i < subtitleBackgroundColorPresets.options.length; i++) {
            if (subtitleBackgroundColorPresets.options?.[i]?.value?.toUpperCase() === selectedValue) {
                subtitleBackgroundColorPresets.selectedIndex = i;
                found = true;
                break;
            }
        }
        if (!found) {
            subtitleBackgroundColorPresets.selectedIndex = -1;
        }
        // Update swatch if color matches
        if (selectedValue === '#D41C1C') {
            setSubtitleBackground('#d41c1c');
        } else if (selectedValue === '#000000') {
            setSubtitleBackground('#000000');
        } else if (selectedValue === '#FFFFFF') {
            setSubtitleBackground('#FFFFFF');
        } else if (selectedValue === 'RGBA(0, 0, 0, 0.5)' || selectedValue === 'RGBA(0,0,0,0.5)') {
            setSubtitleBackground('rgba(0, 0, 0, 0.5)');
        } else {
            subtitleBgEnabled = true;
            subtitleBgColor = subtitleBackgroundColorPicker.value;
            drawCanvas();
        }
    });

    subtitleBackgroundColorPresets.addEventListener('change', () => {
        subtitleBackgroundColorPicker.value = subtitleBackgroundColorPresets.value;
        const color = subtitleBackgroundColorPresets.value;
        if (color === '#d41c1c' || color === '#000000' || color === '#FFFFFF') {
            setSubtitleBackground(color);
        } else {
            subtitleBgEnabled = true;
            subtitleBgColor = color;
            drawCanvas();
        }
    });

    // Gradient background swatch click handlers
    function setGradientBackground(color) {
        // Remove active class from all swatches
        Object.values(gradientBgSwatches).forEach(swatch => {
            if (swatch) swatch.classList.remove('active');
        });
        
        if (color === 'transparent') {
            gradientBgEnabled = false;
            gradientBgSwatches.transparent?.classList.add('active');
        } else {
            gradientBgEnabled = true;
            gradientBgColor = color;
            
            // Set active swatch based on color
            if (color === '#d41c1c') {
                gradientBgSwatches.red?.classList.add('active');
            } else if (color === '#000000') {
                gradientBgSwatches.black?.classList.add('active');
            } else if (color === '#0773D8') {
                gradientBgSwatches.blue?.classList.add('active');
            } else if (color === '#FF009D') {
                gradientBgSwatches.pink?.classList.add('active');
            }
        }
        drawCanvas();
    }
    
    // Add click handlers to gradient swatches
    gradientBgSwatches.transparent?.addEventListener('click', () => setGradientBackground('transparent'));
    gradientBgSwatches.red?.addEventListener('click', () => setGradientBackground('#d41c1c'));
    gradientBgSwatches.black?.addEventListener('click', () => setGradientBackground('#000000'));
    gradientBgSwatches.blue?.addEventListener('click', () => setGradientBackground('#0773D8'));
    gradientBgSwatches.pink?.addEventListener('click', () => setGradientBackground('#FF009D'));
    
    // Initialize with black selected (default)
    setGradientBackground('#000000');

    function handleFontChange() {
        const selectedFont = fontStyleSelect.value;
        if (selectedFont === 'Parkinsans') {
            subtitleColorPicker.value = '#FFF200';
            subtitleColorPresets.value = '#FFF200';
        } else if (selectedFont === 'Fira Sans') {
            subtitleColorPicker.value = '#FFFFFF';
            subtitleColorPresets.value = '#FFFFFF';
        } else if (selectedFont === 'Hanken Grotesk') {
            subtitleColorPicker.value = '#FFFFFF';
            subtitleColorPresets.value = '#FFFFFF';
        } else if (selectedFont === 'Inter') {
            subtitleColorPicker.value = '#FFFFFF';
            subtitleColorPresets.value = '#FFFFFF';
        } else if (selectedFont === 'IBM Plex Sans') {
            subtitleColorPicker.value = '#FFFFFF';
            subtitleColorPresets.value = '#FFFFFF';
        }
        for (let i = 0; i < subtitleColorPresets.options.length; i++) {
            if (subtitleColorPresets.options?.[i]?.value === subtitleColorPicker.value) {
                subtitleColorPresets.selectedIndex = i;
                break;
            }
        }
        // Force immediate redraw and ensure font is loaded
        // First, clear the canvas to remove old font rendering
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Wait for fonts to be ready, then redraw
        if (document.fonts && document.fonts.ready) {
            document.fonts.ready.then(() => {
                // Force a complete redraw
                drawCanvas();
            }).catch(() => {
                // If fonts API fails, redraw immediately
                drawCanvas();
            });
        } else {
            // Fallback: small delay to ensure font loads, then redraw
            setTimeout(() => {
                drawCanvas();
            }, 100);
        }
    }
    
    // Add both change and input event listeners to catch all font changes
    fontStyleSelect.addEventListener('change', handleFontChange);
    fontStyleSelect.addEventListener('input', handleFontChange);

    function hexToRgb(hex) {
        const bigint = parseInt(hex.slice(1), 16);
        const r = (bigint >> 16) & 255;
        const g = (bigint >> 8) & 255;
        const b = bigint & 255;
        return [r, g, b];
    }

    /**
     * Applies French typography rules:
     * - Prevents articles (un, une, les, des, du, de la, l') from being separated from their nouns.
     * - Prevents monosyllabic prepositions (√†, de, ou, et, etc.) from being alone at the end of a line.
     * Achieved by replacing regular spaces with non-breaking spaces (\u00A0)
     * and for l', replacing the standard apostrophe with a non-breaking apostrophe (\u202F).
     * @param {string} text The input text.
     * @returns {string} The text with non-breaking spaces applied for French typography.
     */
    function applyFrenchTypographyRules(text) {
        // Monosyllabic prepositions and articles (add more if needed)
        const monosyllabicWords = [
            'a', '√†', 'aux', 'au', 'dans', 'de', 'des', 'du', 'd√®s', 'en', 'et', 'le', 'la', 'les',
            'ou', 'o√π', 'par', 'pour', 'que', 'qui', 'sa', 'se', 'ses', 'son', 'sous', 'sur', 'un', 'une', 'vers'
        ].join('|');

        // Regex to find these words followed by a space
        const regex = new RegExp(`\\b(${monosyllabicWords})\\s`, 'gi');

        // Replace space with non-breaking space
        let processedText = text.replace(regex, (match, p1) => {
            return p1 + '\u00A0'; // Non-breaking space
        });

        // Special handling for 'l'' to use non-breaking apostrophe
        // Ensure apostrophes (like in "aujourd'hui") also use non-breaking space if followed by a space
        // This regex captures 'word' + "'" + 'space' or 'l' + "'" + 'space'
        processedText = processedText.replace(/(\b\w)'\s/g, (match, p1) => {
            if (p1.toLowerCase() === 'l') {
                return 'l\u202F'; // Non-breaking apostrophe for l'
            }
            return p1 + '\u0027\u00A0'; // Standard apostrophe + non-breaking space for others
        });

        return processedText;
    }

    /**
     * Formats the current date in French format (DayName Day MonthName Year)
     * @returns {string} The formatted date string (e.g., "www.lemauricien.com  ‚Ä∫ Jeudi 15 Janvier 2026")
     */
    function getFrenchDate() {
        const now = new Date();
        const days = ['Dimanche', 'Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi'];
        const months = ['Janvier', 'F√©vrier', 'Mars', 'Avril', 'Mai', 'Juin', 
                       'Juillet', 'Ao√ªt', 'Septembre', 'Octobre', 'Novembre', 'D√©cembre'];
        const dayName = days[now.getDay()];
        const day = now.getDate();
        const monthName = months[now.getMonth()];
        const year = now.getFullYear();
        return `LEMAURICIEN.COM  ‚Ä∫ ${dayName} ${day} ${monthName} ${year}`;
    }

    function drawCanvas() {
      // If bulk mode is enabled, use bulk canvas drawing
      if (bulkModeEnabled) {
        if (processedImages.length > 0) {
          // Show preview of first processed image
          const previewImg = new Image();
          previewImg.onload = () => {
            canvas.width = previewImg.width;
            canvas.height = previewImg.height;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(previewImg, 0, 0);
          };
          previewImg.src = processedImages[0].url;
        } else if (filesToProcess.length > 0) {
          drawBulkCanvas(`Ready to process ${filesToProcess.length} image(s).`);
        } else {
          drawBulkCanvas();
        }
        return;
      }

      // Clear canvas completely to prevent font persistence
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // Reset canvas state to ensure clean font rendering
      ctx.font = 'normal normal normal 12px sans-serif';

      // Draw blurred portrait background if Quote Mode is enabled
      if (quoteModeEnabled && uploadedPortraitImage) {
        ctx.save();
        ctx.filter = 'blur(30px)'; // Apply blur to the background
        
        const imgRatio = uploadedPortraitImage.width / uploadedPortraitImage.height;
        const canvasRatio = canvas.width / canvas.height;
        
        let blurImgW, blurImgH;
        
        // Ensure the blurred background covers the entire canvas
        if (imgRatio > canvasRatio) {
          blurImgH = canvas.height;
          blurImgW = blurImgH * imgRatio;
        } else {
          blurImgW = canvas.width;
          blurImgH = blurImgW / imgRatio;
        }
        
        // Center the blurred background
        const blurX = (canvas.width - blurImgW) / 2;
        const blurY = (canvas.height - blurImgH) / 2;
        
        ctx.drawImage(uploadedPortraitImage, blurX, blurY, blurImgW, blurImgH);
        ctx.filter = 'none'; // Reset filter
        ctx.restore();
        
        // Add slight dark overlay
        ctx.fillStyle = 'rgba(0,0,0,0.1)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }

      // Determine font families and weights based on selection
      const selectedFont = fontStyleSelect.value;
      let subtitleFontFamily, titleFontFamily;
      let subtitleWeight;
      let titleWeight;
      let fontStyle = 'normal'; // Default font style
      let titleFontStyle = 'normal';
      let subtitleFontStyle = 'normal';

      // Get the current title size input value
      let titleSize = parseInt(titleSizeInput.value); // Keep this to allow user override
      
      // Get title weight from dropdown
      titleWeight = titleWeightSelect.value;

      // Handle font selection
      switch (selectedFont) {
        case 'Noto Serif':
          subtitleFontFamily = '"Noto Serif"';
          titleFontFamily = '"Noto Serif"';
          subtitleWeight = quoteModeEnabled ? '500' : '200'; // Medium 500 in quote mode, ExtraLight 200 otherwise
          titleWeight = '400';
          subtitleFontStyle = 'italic';
          titleFontStyle = 'italic';
          break;
        case 'Parkinsans':
          subtitleFontFamily = 'Parkinsans';
          titleFontFamily = 'Parkinsans';
          subtitleWeight = '600';
          break;
        case 'Hanken Grotesk':
          subtitleFontFamily = '"Hanken Grotesk"';
          titleFontFamily = '"Hanken Grotesk"';
          subtitleWeight = '600';
          break;
        case 'Inter':
          subtitleFontFamily = '"Inter"';
          titleFontFamily = '"Inter"';
          subtitleWeight = '600';
          break;
        case 'IBM Plex Sans':
          subtitleFontFamily = '"IBM Plex Sans"';
          titleFontFamily = '"IBM Plex Sans"';
          subtitleWeight = '600';
          break;
        case 'Fira Sans':
        default:
          subtitleFontFamily = 'Fira Sans';
          titleFontFamily = 'Fira Sans';
          subtitleWeight = '700';
          break;
      }

      // If quote mode is enabled and Noto Serif is not explicitly selected, use Noto Serif as default
      if (quoteModeEnabled && selectedFont !== 'Noto Serif') {
        subtitleFontFamily = '"Noto Serif"';
        titleFontFamily = '"Noto Serif"';
        subtitleWeight = '500'; // Medium weight for subtitle in quote mode
        titleWeight = '400';
        subtitleFontStyle = 'italic';
        titleFontStyle = 'italic';
      }

      // Draw main image only if quote mode is not enabled (quote mode uses blurred background instead)
      if (uploadedImage && !quoteModeEnabled) {
        const imgRatio = uploadedImage.width / uploadedImage.height;
        const canvasRatio = canvas.width / canvas.height;

        let mainImgX = 0, mainImgY = 0, mainImgW = canvas.width, mainImgH = canvas.height;

        // Calculate base dimensions for cover/contain
        if (imageCoverMode) { // Cover mode (image fills frame, no blur needed behind)
          if (imgRatio > canvasRatio) { // Image is wider, match canvas height
            mainImgH = canvas.height;
            mainImgW = mainImgH * imgRatio;
          } else { // Image is taller, match canvas width
            mainImgW = canvas.width;
            mainImgH = mainImgW / imgRatio;
          }
        } else { // Fit to Frame (Contain) mode (image is smaller, blur needed behind)
          if (imgRatio < canvasRatio) { // Image is narrower, match canvas height
            mainImgH = canvas.height;
            mainImgW = mainImgH * imgRatio;
          } else { // Image is wider, match canvas width
            mainImgW = canvas.width;
            mainImgH = mainImgW / imgRatio;
          }
        }

        // Apply zoom
        const zoomFactor = currentImageZoom / 100;
        mainImgW *= zoomFactor;
        mainImgH *= zoomFactor;

        // Center the image before applying offsets
        mainImgX = (canvas.width - mainImgW) / 2;
        mainImgY = (canvas.height - mainImgH) / 2;

        // Apply user offsets
        mainImgX += currentImageOffsetX;
        mainImgY += currentImageOffsetY;

        // --- BLURRED BACKGROUND IMAGE (ONLY FOR FIT TO FRAME MODE) ---
        if (!imageCoverMode) { // If it's NOT cover mode, it's fit mode, so apply blur
            ctx.save();
            ctx.filter = 'blur(30px)'; // Apply blur to the background layer
            
            let blurImgW, blurImgH;
            const blurImgRatio = uploadedImage.width / uploadedImage.height;
            const blurCanvasRatio = canvas.width / canvas.height;

            // This ensures the blurred background always 'covers' the entire canvas,
            // even if the main image is in 'fit' mode.
            if (blurImgRatio > blurCanvasRatio) {
                blurImgH = canvas.height;
                blurImgW = blurImgH * blurImgRatio;
            } else {
                blurImgW = canvas.width;
                blurImgH = blurImgW / blurImgRatio;
            }

            blurImgW *= zoomFactor;
            blurImgH *= zoomFactor;

            const blurX = (canvas.width - blurImgW) / 2 + currentImageOffsetX;
            const blurY = (canvas.height - blurImgH) / 2 + currentImageOffsetY;


            ctx.drawImage(uploadedImage, blurX, blurY, blurImgW, blurImgH);
            ctx.filter = 'none'; // Reset filter
            ctx.restore();
        }

        // --- MAIN IMAGE (NO BLUR) ---
        ctx.drawImage(uploadedImage, mainImgX, mainImgY, mainImgW, mainImgH);

        // --- OVERLAY ---
        ctx.fillStyle = 'rgba(0,0,0,0.1)'; // Slight dark overlay
        ctx.fillRect(0, 0, canvas.width, canvas.height);

      } else if (!quoteModeEnabled) {
        // Only show placeholder if quote mode is not enabled
        ctx.fillStyle = '#4a5568';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#a0aec0';
        ctx.font = "700 36px 'Fira Sans', sans-serif"; // Still default font for placeholder
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText("Drag & Drop, Click to Upload, or Paste Image", canvas.width / 2, canvas.height / 2);
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        return;
      }

      // ML Info logo: Position based on format (calculated after text processing)

      // Apply French typography rules to title and subtitle
      const titleRaw = applyFrenchTypographyRules(titleInput.value.trim());
      // In quote mode, subtitle should be in default case (not uppercase)
      const subtitleText = quoteModeEnabled 
        ? subtitleInput.value.trim() 
        : subtitleInput.value.trim().toUpperCase();
      const subtitleRaw = applyFrenchTypographyRules(subtitleText);

      // In quote mode, default to top left placement
      let placement = parseInt(placementInput.value);
      if (quoteModeEnabled) {
        placement = 1; // Top Left
      }
      // titleSize is now set dynamically at the top of the function
      const subtitleSizeAdj = parseInt(subtitleSizeInput.value);
      // subtitleBgEnabled and subtitleBgColor are now managed by swatch selection
      const subtitleTextColor = subtitleColorPicker.value;

      // Adjusted padding for subtitle background
      const paddingLeft = 20; // Increased left padding
      const paddingRight = 20;
      const paddingTop = 15;
      const paddingBottom = 8;

      const borderRadius = 10;

      const maxTextWidth = canvas.width - 100; // 50px left padding + 50px right padding

      let subtitleLines = [];
      // Apply fontStyle to subtitle
      ctx.font = `${subtitleFontStyle} ${subtitleWeight} ${subtitleSizeAdj}px ${subtitleFontFamily}, serif`;
      // Splitting by regular space still works for initial word wrapping logic, as non-breaking spaces are handled by ctx.measureText
      const subtitleWords = subtitleRaw.split(' ');
      let currentSubtitleLine = '';
      for (let word of subtitleWords) {
          const testLine = currentSubtitleLine + word + ' ';
          if (ctx.measureText(testLine).width > maxTextWidth && currentSubtitleLine !== '') {
              subtitleLines.push(currentSubtitleLine.trim());
              currentSubtitleLine = word + ' ';
          } else {
              currentSubtitleLine = testLine;
          }
      }
      if (currentSubtitleLine) subtitleLines.push(currentSubtitleLine.trim());

      if (subtitleLines.length > 2) {
          subtitleLines = subtitleLines.slice(0, 2);
          // Re-evaluate '...' length with the actual font
          // Apply fontStyle to subtitle for '...' measurement
          ctx.font = `${subtitleFontStyle} ${subtitleWeight} ${subtitleSizeAdj}px ${subtitleFontFamily}, serif`;
          if (ctx.measureText(subtitleLines?.[1] + "\u2026").width < maxTextWidth) { // Use U+2026 HORIZONTAL ELLIPSIS
              subtitleLines[1] += "\u2026";
          }
      }
      const subtitleLineHeight = subtitleSizeAdj * 1.05;
      let totalSubtitleHeight = subtitleLines.length * subtitleLineHeight;

      let titleLines = [];
      function wrapTitleLines() {
        titleLines = [];
        let line = '';
        // Apply fontStyle to title
        ctx.font = `${titleFontStyle} ${titleWeight} ${titleSize}px ${titleFontFamily}, serif`;
        // Splitting by regular space still works for initial word wrapping logic
        const words = titleRaw.split(' ');
        for (let word of words) {
          const test = line + word + ' ';
          if (ctx.measureText(test).width > maxTextWidth && line !== '') {
            titleLines.push(line.trim());
            line = word + ' ';
          } else {
            line = test;
          }
        }
        if (line) titleLines.push(line.trim());
        return titleLines.length;
      }

      // Allow up to 8 lines for the title (doubled from 4 since length limit doubled to 400), scaling down from initial 120px, but not below 36px
      while (wrapTitleLines() > 8 && titleSize > 36) { 
        titleSize -= 2;
        // Ensure titleSize does not go below the minimum set in the input field
        if (titleSize < parseInt(titleSizeInput.min)) {
            titleSize = parseInt(titleSizeInput.min);
            break;
        }
      }

      const updatedTitleLineHeight = titleSize * 1.05;

      let textBlockHeight = 0;
      if (subtitleLines.length > 0) {
          textBlockHeight += totalSubtitleHeight;
          if (subtitleBgEnabled) {
              textBlockHeight += (paddingTop + paddingBottom);
          }
          textBlockHeight += 12; // Space between subtitle block and title
      }
      textBlockHeight += titleLines.length * updatedTitleLineHeight;
      textBlockHeight += 50; // Additional bottom padding for subtitle and title block

      // Adjust placement map based on format
      let placementMap;
      if (currentFormat === 'website') {
        // Website format: matches watermarker.html positioning
        placementMap = {
          1: { x: 50, align: 'left', y: 50 }, // Top Left with 50px padding
          3: { x: 50, align: 'left', y: 0 },
          5: { x: canvas.width / 2, align: 'center', y: 50 }, // Top Center with 50px padding
          6: { x: canvas.width / 2, align: 'center', y: 0 }
        };
      } else {
        // Social format: standard positioning
        placementMap = {
          1: { x: 50, align: 'left', y: 150 }, // Top Left with 50px padding
          3: { x: 50, align: 'left', y: 0 },
          5: { x: canvas.width / 2, align: 'center', y: 150 }, // Top Center with 150px padding
          6: { x: canvas.width / 2, align: 'center', y: 0 }
        };
      }

      let posX = placementMap?.[placement]?.x ?? (currentFormat === 'website' ? 50 : 50);
      let align = placementMap?.[placement]?.align ?? 'left';
      
      // Calculate vertical position using slider, respecting padding constraints
      const topPadding = currentFormat === 'website' ? 50 : 100;
      // Adjust bottom padding based on format
      let logoHeight, logoBottomPadding, logoClearance, bottomPadding;
      if (currentFormat === 'website') {
        // Website format (1000x500): matches watermarker.html - 35px bottom + logo height (49px) + 10px clearance
        logoHeight = 49; // Matches watermarker logo height
        logoBottomPadding = 35; // Matches watermarker
        logoClearance = 10; // Reduced clearance for shorter canvas
        bottomPadding = logoHeight + logoBottomPadding + logoClearance; // 94px total
      } else {
        // Social format (1000x1250): standard padding
        logoHeight = 60;
        logoBottomPadding = 50;
        logoClearance = 50;
        bottomPadding = logoHeight + logoBottomPadding + logoClearance; // 160px total
      }
      // Allow text block to go closer to bottom - ensure bottom of block doesn't enter bottom padding area
      const maxY = canvas.height - bottomPadding - textBlockHeight;
      const minY = topPadding;
      const availableRange = Math.max(0, maxY - minY);
      
      // Keep slider max at 100 always to allow full range movement
      if (verticalPositionSlider.max !== "100") {
        verticalPositionSlider.max = "100";
      }
      
      // Get slider value (0-100) and map it to the available range
      let posY;
      if (quoteModeEnabled) {
        // In quote mode, default to 400px from top
        posY = 400;
      } else {
        const sliderValue = parseFloat(verticalPositionSlider.value);
        const sliderPercentage = sliderValue / 100;
        posY = minY + (availableRange * sliderPercentage);
        
        // Ensure posY stays within bounds and bottom of text block doesn't exceed bottom padding
        posY = Math.max(minY, Math.min(maxY, posY));
        // Double-check: ensure bottom of text block (posY + textBlockHeight) doesn't exceed canvas.height - bottomPadding
        if (posY + textBlockHeight > canvas.height - bottomPadding) {
          posY = canvas.height - bottomPadding - textBlockHeight;
        }
      }
      
      // Update display value to show actual pixel position
      verticalPositionValue.textContent = Math.round(posY);

      // Only draw title, subtitle, and gradient for social format
      if (currentFormat === 'social') {
        const gradientPadding = 150;
        let gradient;

        const selectedBlendMode = backgroundBlendMode.value;
        
        // Get color values from gradient swatch selection
        let r, g, b;
        if (gradientBgColor === 'transparent' || !gradientBgEnabled) {
          // Skip gradient drawing if transparent
          r = g = b = 0; // Will be skipped anyway
        } else if (gradientBgColor.startsWith('rgba')) {
          // Handle rgba values
          const rgbaMatch = gradientBgColor.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
          if (rgbaMatch) {
            r = parseInt(rgbaMatch[1]);
            g = parseInt(rgbaMatch[2]);
            b = parseInt(rgbaMatch[3]);
          } else {
            r = g = b = 0;
          }
        } else {
          // Handle hex values
          [r, g, b] = hexToRgb(gradientBgColor);
        }

        // Only draw gradient if enabled (not transparent)
        if (gradientBgEnabled && gradientBgColor !== 'transparent') {
          ctx.save();
          ctx.globalCompositeOperation = selectedBlendMode;

          if (placement === 1 || placement === 5) {
            const gradientEndY = posY + textBlockHeight + gradientPadding;
            gradient = ctx.createLinearGradient(0, 0, 0, gradientEndY);

            gradient.addColorStop(0, `rgba(${r},${g},${b},0.8)`);
            gradient.addColorStop(0.6, `rgba(${r},${g},${b},0.4)`);
            gradient.addColorStop(1, `rgba(${r},${g},${b},0)`);

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, gradientEndY);
          } else if (placement === 3 || placement === 6) {
            const gradientStartY = posY - gradientPadding;
            gradient = ctx.createLinearGradient(0, gradientStartY, 0, canvas.height);

            gradient.addColorStop(0, `rgba(${r},${g},${b},0)`);
            gradient.addColorStop(0.4, `rgba(${r},${g},${b},0.4)`);
            gradient.addColorStop(1, `rgba(${r},${g},${b},0.8)`);

            ctx.fillStyle = gradient;
            ctx.fillRect(0, gradientStartY, canvas.width, canvas.height - gradientStartY);
          }

          ctx.restore();
        }

        ctx.textAlign = align;
        ctx.textBaseline = 'top';
        ctx.shadowColor = 'rgba(0,0,0,0.4)';
        ctx.shadowBlur = 4;
        ctx.shadowOffsetX = 2;
        ctx.shadowOffsetY = 2;

        let currentTextY = posY;

        if (subtitleLines.length > 0) {
            // Apply fontStyle to subtitle
            ctx.font = `${subtitleFontStyle} ${subtitleWeight} ${subtitleSizeAdj}px ${subtitleFontFamily}, serif`;

            let maxSubtitleLineTextWidth = 0;
            for (let line of subtitleLines) {
                maxSubtitleLineTextWidth = Math.max(maxSubtitleLineTextWidth, ctx.measureText(line).width);
            }

            let subtitleBgX = posX;
            if (align === 'center') {
                subtitleBgX -= (maxSubtitleLineTextWidth + paddingLeft + paddingRight) / 2;
            } else if (align === 'right') {
                subtitleBgX -= (maxSubtitleLineTextWidth + paddingLeft + paddingRight);
            } else { // left align
                // For left alignment, background starts at posX to align with title
                subtitleBgX = posX;
            }


            if (subtitleBgEnabled) {
                ctx.fillStyle = subtitleBgColor;
                const bgWidth = maxSubtitleLineTextWidth + paddingLeft + paddingRight;
                const bgY = currentTextY - paddingTop; // Adjusted for new paddingTop
                const bgHeight = totalSubtitleHeight + (paddingTop + paddingBottom); // Adjusted for new paddings

                ctx.beginPath();
                ctx.moveTo(subtitleBgX + borderRadius, bgY);
                ctx.lineTo(subtitleBgX + bgWidth - borderRadius, bgY);
                ctx.quadraticCurveTo(subtitleBgX + bgWidth, bgY, subtitleBgX + bgWidth, bgY + borderRadius);
                ctx.lineTo(subtitleBgX + bgWidth, bgY + bgHeight - borderRadius);
                ctx.quadraticCurveTo(subtitleBgX + bgWidth, bgY + bgHeight, subtitleBgX + bgWidth - borderRadius, bgY + bgHeight);
                ctx.lineTo(subtitleBgX + borderRadius, bgY + bgHeight);
                ctx.quadraticCurveTo(subtitleBgX, bgY + bgHeight, subtitleBgX, bgY + bgHeight - borderRadius);
                ctx.lineTo(subtitleBgX, bgY + borderRadius);
                ctx.quadraticCurveTo(subtitleBgX, bgY, subtitleBgX + borderRadius, bgY);
                ctx.closePath();
                ctx.fill();
            }

            ctx.fillStyle = subtitleTextColor;
            // When left-aligned and background is enabled, push text inside by paddingLeft
            for (let i = 0; i < subtitleLines.length; i++) {
                // For left alignment with background, add paddingLeft to align text inside background
                const textX = (align === 'left' && subtitleBgEnabled) ? posX + paddingLeft : posX;
                ctx.fillText(subtitleLines[i], textX, currentTextY + i * subtitleLineHeight);
            }
            currentTextY += totalSubtitleHeight;

            if (subtitleBgEnabled) {
                currentTextY += (paddingTop + paddingBottom); // Advance Y by full background height
            }
            currentTextY += 12; // Space between subtitle block and title
        }

        ctx.fillStyle = 'white';
        // Apply fontStyle to title
        ctx.font = `${titleFontStyle} ${titleWeight} ${titleSize}px ${titleFontFamily}, serif`;
        
        // Get kerning value
        const kerning = parseFloat(kerningSlider.value);
        
        // Draw title lines with kerning
        for (let i = 0; i < titleLines.length; i++) {
          const line = titleLines?.[i] ?? '';
          const yPos = currentTextY + i * updatedTitleLineHeight;
          
          if (kerning === 0) {
            // No kerning needed
            ctx.fillText(line, posX, yPos);
          } else if (typeof ctx.letterSpacing !== 'undefined') {
            // Use letterSpacing if supported (modern browsers)
            ctx.letterSpacing = `${kerning}px`;
            ctx.fillText(line, posX, yPos);
            ctx.letterSpacing = '0px'; // Reset
          } else {
            // Fallback: draw characters individually with spacing
            let xPos = posX;
            for (let j = 0; j < line.length; j++) {
              ctx.fillText(line[j], xPos, yPos);
              const charWidth = ctx.measureText(line[j]).width;
              xPos += charWidth + kerning;
            }
          }
        }

        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
      }

      // Turf Logo: Top right (if enabled) - positioned below date stamp with clearance
      if (turfLogoToggle.checked && turfLogoLoaded) {
          const turfLogoHeight = 100;
          const turfLogoWidth = turfLogo.width * (turfLogoHeight / turfLogo.height);
          const turfLogoX = canvas.width - turfLogoWidth - 50; // 50px padding from right (same as date)
          const turfLogoY = 100; // Top padding, positioned below date stamp (date is at y=50)
          ctx.drawImage(turfLogo, turfLogoX, turfLogoY, turfLogoWidth, turfLogoHeight);
      }

      // ML Info logo: Position based on format (Quote Mode always uses social format positioning)
      if (mlinfoLogoLoaded) {
        let mlinfoLogoHeight, mlinfoLogoWidth, mlinfoLogoX, mlinfoLogoY;
        // Quote Mode always uses social format positioning (centered at bottom)
        if (currentFormat === 'website' && !quoteModeEnabled) {
          // Website format: matches watermarker.html - left side, 50px from left, 35px from bottom, 49px height
          mlinfoLogoHeight = 49;
          mlinfoLogoWidth = mlinfoLogo.width * (mlinfoLogoHeight / mlinfoLogo.height);
          mlinfoLogoX = 50; // Left padding (matches watermarker)
          mlinfoLogoY = canvas.height - mlinfoLogoHeight - 35; // 35px padding from bottom (matches watermarker)
        } else {
          // Social format or Quote Mode: Center bottom, height 60px, padding 50px from bottom
          mlinfoLogoHeight = 60;
          mlinfoLogoWidth = mlinfoLogo.width * (mlinfoLogoHeight / mlinfoLogo.height);
          mlinfoLogoX = (canvas.width - mlinfoLogoWidth) / 2; // Center horizontally
          mlinfoLogoY = canvas.height - mlinfoLogoHeight - 50; // 50px padding from bottom
        }
        ctx.drawImage(mlinfoLogo, mlinfoLogoX, mlinfoLogoY, mlinfoLogoWidth, mlinfoLogoHeight);
      }

      // --- DATE STAMP (Top Left) - On top layer - Only for social format or Quote Mode ---
      if (currentFormat === 'social' || quoteModeEnabled) {
        ctx.save();
        ctx.font = '400 24px "Inter", sans-serif'; // Small, light font (increased from 22px to 24px)
        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)'; // Transparent white
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        ctx.shadowColor = 'rgba(0, 0, 0, 0.3)'; // Subtle shadow for readability
        ctx.shadowBlur = 2;
        ctx.shadowOffsetX = 1;
        ctx.shadowOffsetY = 1;
        const dateText = getFrenchDate();
        ctx.fillText(dateText, 50, 50); // 50px padding from left, 50px from top
        ctx.restore();
      }

      // --- PORTRAIT CIRCLE (Top Layer) - Draw last so it appears on top of everything ---
      if (quoteModeEnabled && uploadedPortraitImage) {
        // Base portrait circle diameter
        const basePortraitDiameter = 250;
        
        // Apply position zoom to circle size (portraitZoom is 1-300, where 100 = 100%)
        const portraitDiameter = basePortraitDiameter * (portraitZoom / 100);
        
        // Use position sliders for circle position on canvas
        const portraitX = portraitPositionX;
        const portraitY = portraitPositionY;

        // Draw circular portrait
        ctx.save();
        ctx.beginPath();
        ctx.arc(portraitX, portraitY + portraitDiameter / 2, portraitDiameter / 2, 0, Math.PI * 2);
        ctx.closePath();
        ctx.clip();

        // Apply image zoom and pan transformations (for image within circle)
        const imageZoom = portraitImageZoom / 100; // Convert 1-1000 to 0.01-10.0
        const pPanX = portraitPanX;
        const pPanY = portraitPanY;

        // Calculate image dimensions maintaining aspect ratio
        const imgAspect = uploadedPortraitImage.width / uploadedPortraitImage.height;
        let drawWidth, drawHeight;

        if (imgAspect > 1) {
          // Image is wider than tall
          drawHeight = portraitDiameter;
          drawWidth = portraitDiameter * imgAspect;
        } else {
          // Image is taller than wide
          drawWidth = portraitDiameter;
          drawHeight = portraitDiameter / imgAspect;
        }

        // Apply image zoom
        drawWidth *= imageZoom;
        drawHeight *= imageZoom;

        // Calculate draw position with pan adjustments (centered in circle)
        const drawX = portraitX - drawWidth / 2 + pPanX;
        const drawY = (portraitY + portraitDiameter / 2) - drawHeight / 2 + pPanY;

        // Draw the portrait image
        ctx.drawImage(uploadedPortraitImage, drawX, drawY, drawWidth, drawHeight);
        ctx.restore();
      }

      // --- TOP RIGHT LOGO - Top Layer ---
      // For quote mode: use quotes.png at 80% opacity
      if (quoteModeEnabled && quotesLogoLoaded && quotesLogo.complete && quotesLogo.naturalWidth > 0) {
        ctx.save();
        ctx.globalAlpha = 0.8; // 80% opacity
        // Calculate logo size maintaining aspect ratio - 100px width
        const logoWidth = 100; // 100px width
        const logoHeight = quotesLogo.height * (logoWidth / quotesLogo.width);
        // Position top right with 50px right padding and 50px top padding
        const logoX = canvas.width - logoWidth - 50; // 50px from right
        const logoY = 50; // 50px from top
        ctx.drawImage(quotesLogo, logoX, logoY, logoWidth, logoHeight);
        ctx.restore();
      }
      // For social format: use mlinfo.png at 10% opacity
      else if (currentFormat === 'social' && mlinfoTopRightLogoLoaded && mlinfoTopRightLogo.complete && mlinfoTopRightLogo.naturalWidth > 0) {
        ctx.save();
        ctx.globalAlpha = 0.1; // 10% opacity
        // Calculate logo size maintaining aspect ratio - 100px width
        const logoWidth = 100; // 100px width
        const logoHeight = mlinfoTopRightLogo.height * (logoWidth / mlinfoTopRightLogo.width);
        // Position top right with 50px right padding and 50px top padding
        const logoX = canvas.width - logoWidth - 50; // 50px from right
        const logoY = 50; // 50px from top
        ctx.drawImage(mlinfoTopRightLogo, logoX, logoY, logoWidth, logoHeight);
        ctx.restore();
      }
    }

    function downloadImage() {
      const buttonContainer = document.querySelector('.flex.gap-3.pt-4');
      const downloadButton = buttonContainer.querySelector('button:last-child');
      const generateButton = buttonContainer.querySelector('button:first-child');

      const originalDownloadText = downloadButton.textContent;
      downloadButton.textContent = 'Downloading...';
      downloadButton.disabled = true;
      generateButton.disabled = true;

      try {
        const link = document.createElement('a');
        const formatName = currentFormat === 'social' ? 'social-media' : 'website';
        link.download = `${formatName}-image.webp`;
        link.href = canvas.toDataURL('image/webp', 0.8);

        link.click();

        setTimeout(() => {
          downloadButton.textContent = originalDownloadText;
          downloadButton.disabled = false;
          generateButton.disabled = false;
        }, 2000);
      } catch (error) {
        console.error("Download failed:", error);
        alert("Image download failed. Please try again.");
        downloadButton.textContent = originalDownloadText;
        downloadButton.disabled = false;
        generateButton.disabled = false;
      }
    }

    // --- Bulk Mode Functions ---
    const MAX_DIMENSION_ORIGINAL = 2000;
    const MAX_DIMENSION_COMPRESSED = 1920;
    const WEBP_QUALITY_COMPRESSED = 0.7;
    const CENTER_LOGO_WIDTH_RATIO = 0.5;
    const MAX_CENTER_LOGO_WIDTH = 800;
    const BOTTOM_LOGO_HEIGHT_RATIO_ASSET2 = 0.05;
    const BOTTOM_LOGO_HEIGHT_RATIO_MAIN = 0.06;
    const MAX_BOTTOM_LOGO_HEIGHT = 60;
    const LOGO_BOTTOM_PADDING_RATIO = 0.04;
    const LOGO_LEFT_PADDING_RATIO = 0.05;
    const MIN_PADDING_PX = 15;
    const LOGO_SPACING = 10;

    function handleFiles(files) {
      filesToProcess = Array.from(files).filter(file => file.type.startsWith('image/'));
      if (filesToProcess.length === 0) {
        alert("Please select one or more image files.");
        resetBulkUI();
        return;
      }
      
      processedImages = [];
      currentProcessedCount = 0;
      if (processImagesButton) {
        processImagesButton.disabled = false;
        processImagesButton.textContent = `Process ${filesToProcess.length} Image(s)`;
      }
      if (downloadAllButton) downloadAllButton.classList.add('hidden');
      if (bulkProcessingStatus) bulkProcessingStatus.classList.add('hidden');
      drawBulkCanvas(`Ready to process ${filesToProcess.length} image(s).`);
    }

    function resetBulkUI() {
      filesToProcess = [];
      processedImages = [];
      currentProcessedCount = 0;
      if (imageInput) imageInput.value = '';
      if (processImagesButton) {
        processImagesButton.disabled = true;
        processImagesButton.textContent = 'Process Images';
      }
      if (downloadAllButton) downloadAllButton.classList.add('hidden');
      if (bulkProcessingStatus) bulkProcessingStatus.classList.add('hidden');
      drawBulkCanvas();
      if (outputSizeRadios && outputSizeRadios.length > 0) {
        const originalRadio = Array.from(outputSizeRadios).find(r => r.value === 'original');
        if (originalRadio) originalRadio.checked = true;
      }
      currentOutputSetting = 'original';
    }

    function drawBulkCanvas(message = "Upload or Drag & Drop Multiple Images Here") {
      if (!bulkModeEnabled) return;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#4a5568';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#a0aec0';
      ctx.font = "700 24px 'Fira Sans', sans-serif";
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(message, canvas.width / 2, canvas.height / 2);
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
    }

    // Handle output size selection
    if (outputSizeRadios) {
      outputSizeRadios.forEach(radio => {
        radio.addEventListener('change', (event) => {
          currentOutputSetting = event.target.value;
        });
      });
    }

    function processSelectedFiles() {
      if (filesToProcess.length === 0) {
        alert("No images selected for processing. Please select images first.");
        return;
      }

        // Check if watermarks are loaded - wait if needed (center logo and bottom mlinfo logo)
        const checkWatermarks = () => {
          if (!watermarkLogoLoaded || 
              !watermarkLogo.complete ||
              watermarkLogo.naturalWidth === 0 ||
              !mlinfoLogoLoaded ||
              !mlinfoLogo.complete ||
              mlinfoLogo.naturalWidth === 0) {
            console.warn('Watermarks not fully loaded yet, waiting...', {
              centerLogoLoaded: watermarkLogoLoaded,
              centerLogoComplete: watermarkLogo.complete,
              centerLogoWidth: watermarkLogo.naturalWidth,
              bottomLogoLoaded: mlinfoLogoLoaded,
              bottomLogoComplete: mlinfoLogo.complete,
              bottomLogoWidth: mlinfoLogo.naturalWidth
            });
            setTimeout(checkWatermarks, 100);
            return;
          }

          // Reset processed images array
          processedImages = [];
          currentProcessedCount = 0;

          if (processImagesButton) processImagesButton.disabled = true;
          if (downloadAllButton) downloadAllButton.classList.add('hidden');
          if (bulkProcessingStatus) bulkProcessingStatus.classList.remove('hidden');
          if (bulkProcessedCountText) bulkProcessedCountText.textContent = `Processing 0/${filesToProcess.length}...`;
          drawBulkCanvas("Processing images...");

          console.log('Starting image processing with watermarks:', {
            centerLogoLoaded: watermarkLogoLoaded,
            bottomLogoLoaded: mlinfoLogoLoaded
          });

          processImage(0);
        };

        checkWatermarks();
    }

    function processImage(index) {
      if (index >= filesToProcess.length) {
        // All images processed
        if (processImagesButton) {
          processImagesButton.disabled = false;
          processImagesButton.textContent = 'Processing Complete!';
        }
        if (downloadAllButton) downloadAllButton.classList.remove('hidden');
        if (bulkProcessedCountText) bulkProcessedCountText.textContent = `Processed ${processedImages.length}/${filesToProcess.length} images.`;
        // Display the first processed image as a preview
        if (processedImages.length > 0) {
          const previewImg = new Image();
          previewImg.onload = () => {
            canvas.width = previewImg.width;
            canvas.height = previewImg.height;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(previewImg, 0, 0);
          };
          previewImg.src = processedImages[0].url;
        } else {
          drawBulkCanvas("No images processed successfully.");
        }
        return;
      }

      const file = filesToProcess[index];
      const reader = new FileReader();

      reader.onload = (e) => {
        const img = new Image();
        img.onload = () => {
          // Verify watermarks are still ready before processing this image (center logo and bottom mlinfo logo)
          const watermarksReady = 
            watermarkLogoLoaded && watermarkLogo.complete && watermarkLogo.naturalWidth > 0 &&
            mlinfoLogoLoaded && mlinfoLogo.complete && mlinfoLogo.naturalWidth > 0;
          
          if (!watermarksReady) {
            console.error(`Watermarks not ready for image ${index + 1} (${file.name}). Retrying...`, {
              centerLogo: { loaded: watermarkLogoLoaded, complete: watermarkLogo.complete, width: watermarkLogo.naturalWidth },
              bottomLogo: { loaded: mlinfoLogoLoaded, complete: mlinfoLogo.complete, width: mlinfoLogo.naturalWidth }
            });
            // Retry after a short delay
            setTimeout(() => processImage(index), 200);
            return;
          }

          let originalWidth = img.width;
          let originalHeight = img.height;
          let newWidth = originalWidth;
          let newHeight = originalHeight;

          let maxDimension;
          let outputQuality = 1.0;
          let outputMimeType = 'image/webp';

          if (currentOutputSetting === 'compressed') {
            maxDimension = MAX_DIMENSION_COMPRESSED;
            outputQuality = WEBP_QUALITY_COMPRESSED;
          } else {
            maxDimension = MAX_DIMENSION_ORIGINAL;
          }

          // Scale down if dimensions exceed maxDimension
          if (originalWidth > maxDimension || originalHeight > maxDimension) {
            const scaleFactor = Math.min(maxDimension / originalWidth, maxDimension / originalHeight);
            newWidth = originalWidth * scaleFactor;
            newHeight = originalHeight * scaleFactor;
          }

          // Create off-screen canvas for processing
          const offscreenCanvas = document.createElement('canvas');
          const offscreenCtx = offscreenCanvas.getContext('2d');
          offscreenCanvas.width = newWidth;
          offscreenCanvas.height = newHeight;

          // LAYER 1: Blur Background
          offscreenCtx.save();
          offscreenCtx.filter = 'blur(30px)';
          let blurImgW = newWidth, blurImgH = newHeight;
          const blurImgRatio = originalWidth / originalHeight;
          const offscreenCanvasRatio = offscreenCanvas.width / offscreenCanvas.height;
          if (blurImgRatio < offscreenCanvasRatio) {
            blurImgH = offscreenCanvas.width / blurImgRatio;
            blurImgW = offscreenCanvas.width;
          } else {
            blurImgW = offscreenCanvas.height * blurImgRatio;
            blurImgH = offscreenCanvas.height;
          }
          offscreenCtx.drawImage(img, (offscreenCanvas.width - blurImgW) / 2, (offscreenCanvas.height - blurImgH) / 2, blurImgW, blurImgH);
          offscreenCtx.filter = 'none';
          offscreenCtx.restore();

          // LAYER 2: Main Image
          offscreenCtx.save();
          offscreenCtx.drawImage(img, 0, 0, newWidth, newHeight);
          offscreenCtx.fillStyle = 'rgba(0,0,0,0.1)';
          offscreenCtx.fillRect(0, 0, newWidth, newHeight);
          offscreenCtx.restore();

          // LAYER 3: Center Watermark Logo
          let centerLogoDrawn = false;
          if (watermarkLogoLoaded && watermarkLogo.complete && watermarkLogo.naturalWidth > 0) {
            offscreenCtx.save();
            let centerLogoWidth = newWidth * CENTER_LOGO_WIDTH_RATIO;
            if (centerLogoWidth > MAX_CENTER_LOGO_WIDTH) {
              centerLogoWidth = MAX_CENTER_LOGO_WIDTH;
            }
            const centerLogoHeight = watermarkLogo.height * (centerLogoWidth / watermarkLogo.width);
            const centerLogoX = (newWidth - centerLogoWidth) / 2;
            const centerLogoY = (newHeight - centerLogoHeight) / 2;
            offscreenCtx.globalAlpha = 0.04;
            offscreenCtx.drawImage(watermarkLogo, centerLogoX, centerLogoY, centerLogoWidth, centerLogoHeight);
            offscreenCtx.restore();
            centerLogoDrawn = true;
          } else {
            console.warn(`[Image ${index + 1}] Center watermark logo not loaded or invalid:`, {
              loaded: watermarkLogoLoaded,
              complete: watermarkLogo.complete,
              width: watermarkLogo.naturalWidth,
              height: watermarkLogo.naturalHeight
            });
          }

          // LAYER 4: Bottom Logo (mlinfo_lm.png - bottom left, 50px left, 50px bottom)
          offscreenCtx.save();
          let bottomLogoDrawn = false;
          
          // Draw mlinfo_lm.png at bottom left with 50px padding
          if (mlinfoLogoLoaded && mlinfoLogo.complete && mlinfoLogo.naturalWidth > 0) {
            const mlinfoLogoHeight = 60; // Same height as social image
            const mlinfoLogoWidth = mlinfoLogo.width * (mlinfoLogoHeight / mlinfoLogo.height);
            const mlinfoLogoX = 50; // 50px from left
            const mlinfoLogoY = newHeight - mlinfoLogoHeight - 50; // 50px from bottom
            offscreenCtx.globalAlpha = 1.0;
            offscreenCtx.drawImage(mlinfoLogo, mlinfoLogoX, mlinfoLogoY, mlinfoLogoWidth, mlinfoLogoHeight);
            bottomLogoDrawn = true;
          } else {
            console.warn(`[Image ${index + 1}] Bottom logo (mlinfo_lm.png) watermark not loaded or invalid:`, {
              loaded: mlinfoLogoLoaded,
              complete: mlinfoLogo.complete,
              width: mlinfoLogo.naturalWidth,
              height: mlinfoLogo.naturalHeight
            });
          }
          offscreenCtx.restore();
          
          // Store watermark drawing status for logging
          const watermarksDrawn = {
            centerLogo: centerLogoDrawn,
            bottomLogo: bottomLogoDrawn
          };

          // Store processed image
          const processedDataUrl = offscreenCanvas.toDataURL(outputMimeType, outputQuality);
          processedImages.push({ name: file.name, url: processedDataUrl });
          
          // Detailed watermark status logging
          const watermarkStatus = {
            centerLogo: {
              loaded: watermarkLogoLoaded,
              complete: watermarkLogo.complete,
              naturalWidth: watermarkLogo.naturalWidth,
              naturalHeight: watermarkLogo.naturalHeight,
              drawn: centerLogoDrawn
            },
            bottomLogo: {
              loaded: mlinfoLogoLoaded,
              complete: mlinfoLogo.complete,
              naturalWidth: mlinfoLogo.naturalWidth,
              naturalHeight: mlinfoLogo.naturalHeight,
              drawn: bottomLogoDrawn
            }
          };
          
          console.log(`‚úÖ Processed image ${index + 1}/${filesToProcess.length}: ${file.name}`, watermarkStatus);
          
          // Warn if watermarks weren't drawn
          if (!watermarkStatus.centerLogo.drawn || !watermarkStatus.bottomLogo.drawn) {
            console.error(`‚ùå Some watermarks were NOT drawn on ${file.name}:`, {
              centerLogo: watermarkStatus.centerLogo.drawn ? '‚úì' : '‚úó',
              bottomLogo: watermarkStatus.bottomLogo.drawn ? '‚úì' : '‚úó'
            });
          } else {
            console.log(`‚úì All watermarks drawn successfully on ${file.name}`);
          }

          currentProcessedCount++;
          if (bulkProcessedCountText) bulkProcessedCountText.textContent = `Processing ${currentProcessedCount}/${filesToProcess.length}...`;

          processImage(index + 1);
        };
        img.onerror = () => {
          console.error(`Error loading image: ${file.name}`);
          currentProcessedCount++;
          if (bulkProcessedCountText) bulkProcessedCountText.textContent = `Processing ${currentProcessedCount}/${filesToProcess.length}... (Error with ${file.name})`;
          processImage(index + 1);
        };
        img.src = e.target.result;
      };
      reader.readAsDataURL(file);
    }

    function downloadAllImages() {
      if (processedImages.length === 0) {
        alert("No images processed yet.");
        return;
      }

      if (downloadAllButton) {
        downloadAllButton.textContent = 'Downloading...';
        downloadAllButton.disabled = true;
      }

      let downloadCounter = 0;
      processedImages.forEach((image, i) => {
        setTimeout(() => {
          const link = document.createElement('a');
          link.download = `watermarked_${image.name.replace(/\.[^/.]+$/, "")}.webp`;
          link.href = image.url;
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);

          downloadCounter++;
          if (downloadCounter === processedImages.length) {
            alert(`Successfully initiated download for ${processedImages.length} images.`);
            if (downloadAllButton) {
              downloadAllButton.textContent = 'Download All Watermarked';
              downloadAllButton.disabled = false;
            }
            resetBulkUI();
          }
        }, i * 100);
      });
    }

    window.onload = () => {
        subtitleInput.value = ""; // Empty subtitle field
        titleInput.value = ""; // Empty title field

        // Set default values
        titleSizeInput.value = "70";
        subtitleSizeInput.value = "40";
        titleWeightSelect.value = "600";
        kerningSlider.value = "-2";
        kerningValue.textContent = "-2";
        placementInput.value = "3"; // Bottom Left
        verticalPositionSlider.value = "100"; // Maximum (bottom)
        titleSizeInput.setAttribute("max", "140");

        // Check for target format from localStorage (when switching from quote mode)
        const targetFormat = localStorage.getItem('targetFormat');
        if (targetFormat) {
          if (targetFormat === 'website') {
            currentFormat = 'website';
            formatWebsite.classList.add('active');
            formatSocial.classList.remove('active');
          } else if (targetFormat === 'bulk') {
            // Enable bulk mode
            bulkModeEnabled = true;
            bulkModeToggle.classList.add('active');
            bulkModeSection.classList.remove('hidden');
            
            // Disable format buttons (Social/Website) - they stay visible but inactive
            formatSocial.classList.remove('active');
            formatWebsite.classList.remove('active');
            
            // Hide image creator controls (but keep drop zone visible)
            const controlsToHide = [
              'imageSizeMode',
              'imagePositionControls',
              'subtitle',
              'title',
              'fontStyleSelect',
              'placement',
              'advancedOptionsToggle',
              'advancedOptions'
            ];
            controlsToHide.forEach(id => {
              const el = document.getElementById(id);
              if (el) el.style.display = 'none';
            });
            
            // Hide specific controls: Text Block Vertical Position, Title Size, Subtitle Size
            const verticalPositionLabel = document.querySelector('label:has(#verticalPositionValue)');
            if (verticalPositionLabel && verticalPositionLabel.parentElement) {
              verticalPositionLabel.parentElement.style.display = 'none';
            }
            // Hide Title Size and Subtitle Size - hide the entire grid container
            const titleSizeInput = document.getElementById('titleSize');
            const subtitleSizeInput = document.getElementById('subtitleSize');
            if (titleSizeInput && titleSizeInput.parentElement && titleSizeInput.parentElement.parentElement) {
              titleSizeInput.parentElement.parentElement.style.display = 'none';
            }
            // Also hide labels individually as backup
            const titleSizeLabel = document.querySelector('label[for="titleSize"]');
            if (titleSizeLabel && titleSizeLabel.parentElement) {
              titleSizeLabel.parentElement.style.display = 'none';
            }
            const subtitleSizeLabel = document.querySelector('label[for="subtitleSize"]');
            if (subtitleSizeLabel && subtitleSizeLabel.parentElement) {
              subtitleSizeLabel.parentElement.style.display = 'none';
            }
            
            // Hide subtitle background and gradient shadow section (now in a grid)
            const subtitleBgTransparent = document.getElementById('subtitleBgTransparent');
            if (subtitleBgTransparent) {
              let parent = subtitleBgTransparent.parentElement;
              while (parent && !parent.classList.contains('grid')) {
                parent = parent.parentElement;
              }
              if (parent && parent.classList.contains('grid')) {
                parent.style.display = 'none';
              }
            }
            
            // Hide Generate Image button (keep format buttons visible)
            const generateButton = document.querySelector('.generate-button');
            if (generateButton) generateButton.style.display = 'none';
            
            // Keep drop zone visible but update for bulk mode
            if (imageDropZone) {
              imageDropZone.style.display = '';
              // Update drop zone text
              const dropZoneText = document.getElementById('dropZoneText');
              if (dropZoneText) dropZoneText.textContent = 'Drag & Drop multiple images here';
              // Show bulk select button
              const bulkSelectButton = document.getElementById('bulkSelectButton');
              if (bulkSelectButton) bulkSelectButton.classList.remove('hidden');
            }
            
            // Update image input to accept multiple files
            if (imageInput) imageInput.setAttribute('multiple', 'multiple');
            
            // Reset bulk UI
            resetBulkUI();
          } else {
            // targetFormat is 'social' or anything else, use social as default
            currentFormat = 'social';
          }
          // Clear targetFormat from localStorage after restoring
          localStorage.removeItem('targetFormat');
        } else {
          // Initialize format (social by default)
          currentFormat = 'social';
        }
        updateCanvasSize();
        
        // Initialize portrait state from inputs (defaults: X=200, Y=100, Zoom=100)
        if (portraitPositionXInput) {
          portraitPositionX = parseFloat(portraitPositionXInput.value);
        }
        if (portraitPositionYInput) {
          portraitPositionY = parseFloat(portraitPositionYInput.value);
        }
        if (portraitZoomInput) {
          portraitZoom = parseFloat(portraitZoomInput.value);
        }
        if (portraitImageZoomInput) {
          portraitImageZoom = parseFloat(portraitImageZoomInput.value);
        }
        if (portraitPanXInput) {
          portraitPanX = parseFloat(portraitPanXInput.value);
        }
        if (portraitPanYInput) {
          portraitPanY = parseFloat(portraitPanYInput.value);
        }
        
        // Check if quote mode should be enabled from localStorage
        if (localStorage.getItem('quoteModeEnabled') === 'true') {
          quoteModeEnabled = true;
          quoteModeToggle.classList.add('active');
          quoteModeSection.classList.remove('hidden');
          
          // Disable format buttons (Social/Website) - they stay visible but inactive
          formatSocial.classList.remove('active');
          formatWebsite.classList.remove('active');
          
          // Set Noto Serif as default font when quote mode is enabled
          if (fontStyleSelect && fontStyleSelect.value !== 'Noto Serif') {
            fontStyleSelect.value = 'Noto Serif';
          }
          // Set default placement to top left (1) when quote mode is enabled
          if (placementInput) {
            placementInput.value = "1";
          }
          // Set default vertical position to 400px when quote mode is enabled
          if (verticalPositionSlider) {
            verticalPositionSlider.value = "0"; // Will be overridden to 400px in drawCanvas
          }
          // Hide Fill Frame button and main image controls when quote mode is on
          if (imageSizeModeButton) imageSizeModeButton.style.display = 'none';
          if (document.getElementById('imagePositionControls')) {
            document.getElementById('imagePositionControls').style.display = 'none';
          }
          
          // Update canvas size to social format when quote mode is enabled
          updateCanvasSize();
          resetImageTransforms();
        }
        
        drawCanvas();
        // Manually trigger the font style change to set initial subtitle color correctly
        fontStyleSelect.dispatchEvent(new Event('change'));
    };
  </script>
</body>
</html>